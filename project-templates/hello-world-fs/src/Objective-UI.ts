/**
 * A UIPage implementation is the first 
 * Objective-UI class that is instantiated once the page loads.
 * 
 * This class is responsible for initializing the rest of the 
 * Objective-UI library and navigating to the first UIView to be displayed.
 * 
 * Here it is also possible to enable features such as Splitting, Storage, 
 * and also import native JavaScript-CSS libraries
 * 
 * UIPage will initialize a `PageShell` and act in conjunction with it 
 * to manipulate the DOM of the page as a general.
 */
export abstract class UIPage
{
    public static readonly PRODUCT_VERSION: string = '0.8.1'
    public static DISABLE_EXCEPTION_PAGE: boolean = false;
    protected mainShell: PageShell;

    constructor(doc: Document)
    {
        this.mainShell = new PageShell(doc, this);
    }

    protected setStorageProvider(provider: IAppStorageProvider): void
    {
        this.mainShell.setStorageProvider(provider);
    }

    protected enableSplitting(appContainerId: string, splitContainerId: string): void
    {
        this.mainShell.enableSplitting(appContainerId, splitContainerId);
    }

    protected setLibRoot(rootPath: string): void
    {
        PageShell.LIB_ROOT = rootPath;
    }

    protected importLib({ libName, cssPath, jsPath }: { libName: string; cssPath?: string; jsPath?: string; })
    {
        this.mainShell.import(new NativeLib({ libName, cssPath, jsPath }));
    }

    public navigateToView(view: UIView): void
    {
        try
        {
            view.initialize(this.mainShell);
        }
        catch(error)
        {
            new DefaultExceptionPage(error as Error);
        }
    }
}
/**
 * A UIView represents an interface view set of user controls.
 * UIView's are loaded and unloaded all the time and they 
 * house a set of Widgets that give meaning to the view in 
 * front of the user. 
 * 
 * We can say in general terms that 
 * "this is a 'screen' of the application"
 */
export abstract class UIView implements INotifiable
{
    /**
     * You must return a `ViewLayout` class instance to 
     * define the layout demarcations for this View
     * 
     * See:
     * ```
     *  class ViewLayout
     * ```
     */
    abstract buildLayout(): ViewLayout;

    /**
     * You must attach your Widgets variables with the divs 
     * contained in the Layout. 
     * Inside here, call the function `UIView.addWidgets(string, array)`
     * 
     * You **MUST NOT** manipulate the Widgets here (access attributes and functions directly), because they don't exist yet
     * 
     * Example:
     * ```
     * composeView(): void {
     *    this.addWidgets('form-div-id', this.txtName, this.txtMail);
     *    this.addWidgets('actionbar-div-id', this.btnSend, this.btnClear);
     * }
     * ``` 
     * 
     */
    abstract composeView(): void;

    /**
     * When the entire View has been rendered, 
     * you can manipulate the Widgets properties, attributes, styles 
     * and other features here.
     * 
     * You can retrieve and modify properties of divs generated by `ViewLayout` (`Row` and `Col`)
     * 
     * You can also change Widget styles through 
     * standard Widget superclass functions
     * 
     * Can load data into Widgets and do all necessary 
     * logical manipulation in your UIView from now on
     * 
     * [EXAMPLE]
     * ```
onViewDidLoad(): void
{
    //get and style a div (by id) defined in ViewLayout
    var nav = this.shellPage.elementById('nav') as HTMLDivElement;
    nav.style.background = '#007bff';
    //apply batch css to a UIHead
    this.title.applyAllCSS([
        { p: 'padding', v: '10px' },
        { p: 'color', v: 'white' }
    ])
    //apply raw-string css in a UIList
    this.sideMenu.cssFromString('margin-top: 10px;')
    //loading an array of items to the UIList
    this.sideMenu.fromList(['Customers', 'Technical Users (support)']);
}
     * ```
     */
    abstract onViewDidLoad(): void;

    /**
     * (Optional overwrite) occurs when a Widget sends a message
     */
    public onWidgetMessage(message: WidgetMessage): void
    { }

    private view: UIView;
    protected shellPage: PageShell;
    private widgetContext: WidgetContext;
    private customPresenter?: ILayoutPresenter;
    protected buildedLayout: ViewLayout;

    constructor(customLayoutPresenter?: ILayoutPresenter)
    {
        this.customPresenter = customLayoutPresenter;
    }

    /**
     * Request an instance of the Storage implementation 
     * for Session or Local storage by implementing IAppStorageProvider
     * 
     * see:
     * 
     * ```
     * interface IAppStorageProvider
     * ```
     * @param schemaName A unique id-name to determine the data scope
     */
    protected requestLocalStorage(schemaName: string): AppStorage
    {
        return this.shellPage.requestStorage('local', schemaName);
    }

    protected requestSessionStorage(schemaName: string): AppStorage
    {
        return this.shellPage.requestStorage('session', schemaName);
    }

    protected viewContext(): WidgetContext
    {
        return this.widgetContext;
    }

    protected inflateTemplateView(rawHtml: string) : UITemplateView
    {
        return new UITemplateView(rawHtml, this.shellPage);
    }

    onNotified(sender: any, args: any[]): void
    {
        if (sender == 'FSWidgetContext')
            this.onViewDidLoad();
    }

    public initialize(mainShell: PageShell)
    {
        this.shellPage = mainShell;

        this.buildedLayout = this.buildLayout();
        this.buildedLayout.render(mainShell, this.customPresenter);

        var layoutCollection: string[] = this.buildedLayout.ElementsIdCollection();

        this.widgetContext = new WidgetContext(
            this.shellPage,
            layoutCollection,
            this.onWidgetMessage);

        this.view = this;
        this.view.composeView();
        this.widgetContext.build(this);
    }

    /**
     * Get all Widgets attached and managed in this UIView
     */
    public managedWidgets():Array<Widget>
    {
        if (this.widgetContext == null || this.widgetContext == undefined)
            return [];
        return this.widgetContext.getManagedWidgets();
    }

    /**
     * Adds one or more Widgets to a div specified in `ViewLayout`
     * @param layoutId An 'Id' of div contained in the `ViewLayout` class
     * @param widgets An array of Widget objects that will be bound to 'layoutId'
     */
    protected addWidgets(layoutId: string, ...widgets: Widget[]): void
    {
        for (var i = 0; i < widgets.length; i++)
            this.widgetContext.addWidget(layoutId, widgets[i]);
    }

    /**
     * Remove a Widget managed by this UIView
     */
    protected removeWidget(widget: Widget): void
    {
        this.viewContext().removeWidget(widget);
    }

    /**
     * Finds a Widget managed by this UIView
     *
     * @param layoutId An 'Id' div contained in the `ViewLayout`class
     * @param widgetName The name of a Widget managed by this UIView and previously attached to the ViewLayout through the specified 'layoutId'
     */
    protected findWidget(layoutId: string, widgetName: string): Widget
    {
        return this.viewContext().findWidget(layoutId, widgetName);
    }

    /**
     * Create an alternative Widget Context that allows controlling 
     * a set of Widgets that are outside the main Div-app or that 
     * are in a different Div than the one used by the original 
     * Context of this UIView
     * @param managedDivIds The set of 'Id' divs managed by this Context Widget
     * @param messageProtocol A function that responds to the message triggered by this context indicating its complete loading
     */
    protected createWidgetContext(managedDivIds: string[], messageProtocol?: Function): WidgetContext
    {
        if (null == this.shellPage || undefined == this.shellPage)
            throw 'FSView.createWidgetContext(): It is not possible to do this as the View is not yet initialized. If you are making this call inside the constructor(), move it inside the composeView() function.';

        return new WidgetContext(
            this.shellPage,
            managedDivIds,
            messageProtocol
        );
    }
}
/**
A Widget is a TS object that represents a piece of HTML. It is able to
fetch that piece of html into a webdir and bring it to the MainPage.
of a WidgetContext and can manage several child Widgets.

It is also able to manage the elements marked with "id" attribute within that piece of HTML,
and then make them available to the inherited class as DOM objects.
 * 
 */
export abstract class Widget implements INotifiable
{
    /**
     * This function (in the inherited object) is triggered when "renderView()" 
     * manages to get the HTML resource from the WebDir and bind it to this Widget.
     * 
     * Within this function, it is possible to access and manipulate the DOM Elements 
     * present in the HTML resource, by calling 
     * "elementById<TElement>(string)"
     */
    protected abstract onWidgetDidLoad(): void;
    protected abstract htmlTemplate(): string;

    /**
     * Occurs when the Widget is detached from the WidgetContext
     */
    public onWidgetDetached(): void
    {

    }

    /**
     * Defines an instance (of the implementation) of a custom presenter for this Widget.
     *  
     * Custom presenter may contain some specific logic for styling the DOM elements managed by these Widgets.
     * @param presenter 
     */
    public abstract setCustomPresenter(presenter: ICustomWidgetPresenter<Widget>): void;

    /**
     * Gets the default value of this widget; Note that not every Widget will implement the return of its value by this function.
     */
    public abstract value(): string;

    public abstract setEnabled(enabled: boolean): void

    /**
     * Add a CSS class by name; Some Widgets may not implement this eventually.
     * @param className CSS class name
     */
    public abstract addCSSClass(className: string): void;

    /**
     * Remove a CSS class by name; Some Widgets may not implement this eventually.
     * @param className CSS class name
     */
    public abstract removeCSSClass(className: string): void;

    /**
     * Applies a CSS property value; Some Widgets may not implement this eventually.
     * @param propertyName CSS property name
     * @param propertyValue Property value
     */
    public abstract applyCSS(propertyName: string, propertyValue: string): void;

    /**
     * Change Widget Position
     * @param position Position mode. Valid values are: 'absolute', 'relative', 'fixed', 'sticky', 'static' https://developer.mozilla.org/pt-BR/docs/Web/CSS/position
     * @param marginBottom A margin bottom value
     * @param marginLeft A margin left value
     * @param transform (optional) indicates the CSS value of 'Transform' https://developer.mozilla.org/pt-BR/docs/Web/CSS/transform
     */
    public abstract setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void;

    /**
     * Determines if this Widget is visible on the page
     * @param visible True or False
     */
    public abstract setVisible(visible: boolean): void;

    /**
     * 
     * @param propertyPairs Array item: [{ p: 'xxx', v: 'vvv'}, ...]
     */
    public applyAllCSS(propertyPairs: Array<any>): void
    {
        for (var i = 0; i < propertyPairs.length; i++)
        {
            var css = propertyPairs[i];
            this.applyCSS(css.p, css.v);
        }
    }

    public cssFromString(cssString: string): void
    {
        var statements = cssString.split(';');
        for(var i = 0; i < statements.length; i++)
        {
            var statement = statements[i];
            if(statement == '') continue;
            var parts = statement.split(':');
            if(parts.length == 0) continue;
            var key = parts[0].trim();
            if(key == '')continue;
            var value = parts[1].trim();
            this.applyCSS(key, value);
        }
    }

    public widgetName: string;

    private viewDictionary: ViewDictionaryEntry[];
    private DOM: Document; //DOM js object of html
    private parentFragment?: WidgetFragment;

    /**
     * 
     * @param resourceName The name of the html resource that will be fetched from the webdir and linked to this Widget
     * @param widgetName A name for this Widget instance
     */
    constructor(widgetName: string)
    {
        this.widgetName = widgetName;
        this.viewDictionary = [];
        this.DOM;
    }

    public replaceCSSClass(oldClass: string, newClass: string)
    {
        this.removeCSSClass(oldClass);
        this.addCSSClass(newClass);
    }

    public getPageShell(): PageShell
    {
        try
        {
            return this.getOwnerFragment()
                .contextRoot
                .shellPage;
        } catch (error)
        {
            throw new Error(`Attempt to access or manipulate an unattached Widget. Check if the Widget was attached during the composeView() function of the respective View that originated this call.`);
        }
    }


    /**
     * Get the fragment (page div) that this widget owns
     * @returns WidgetFragment
     */
    public getOwnerFragment(): WidgetFragment
    {
        return this.parentFragment;
    }

    /**
     * Determines the fragment (page div) that this widget owns
     */
    public setParentFragment(parentFragment: WidgetFragment): void
    {
        this.parentFragment = parentFragment;
    }

    /**
     * Sends a message from the inherited object towards the WidgetContext,
     * which then makes it available to the UIView in the "onWidgetMessage()" function call
     * @param messageId Set a default identifier for this message. This allows the receiver to determine the type of message (your widget may have some)
     * @param messageText A text for your message
     * @param messageAnyObject A custom data object
     */
    protected sendMessage(messageId: number, messageText: string, messageAnyObject: object): void
    {
        this.parentFragment?.pushMessageToRoot(this.widgetName, messageId, messageText, messageAnyObject);
    }

    protected processError(error: unknown)
    {
        new DefaultExceptionPage(error as unknown as Error);
        throw error;
    }

    /**
     * Get the Element object (DOM) respective to the entire html 
     * resource linked to the Widget 
     * 
     * If the HTML contains more than one element, you must use a DIV 
     * involving all of them and marked with an "id" attribute
     * @returns Element instance
     */
    public getDOMElement(): Element
    {
        if (this.viewDictionary.length == 0) return null;
        var firstId: string = this.viewDictionary[0].getOriginalId();
        return this.elementById(firstId);
    }


    /**
     * Gets a DOM object element from the value of the "id" attribute.
     * @param elementId Element id inside of the html template provided by inherited class
     * @returns 
     */
    protected elementById<TElement>(elementId: string): TElement
    {
        var pageShell = this.getPageShell();
        for (var i = 0; i < this.viewDictionary.length; i++)
        {
            var entry: ViewDictionaryEntry = this.viewDictionary[i];
            if (entry.getOriginalId() == elementId)
            {
                var elementResult: any = pageShell.elementById(entry.getManagedId());
                return elementResult;
            }
        }
        return null;
    }

    /**
    Adds an entry in the Id's dictionary. 
    The dictionary is used to prevent conflicting element IDs across the page.

    Before elements are attached to the page, a unique Id value is generated and (re)set 
    to the element. 

    The dictionary maintains exactly the parity of the auto-generated Id 
    with the original one, so that the inherited object can normally access 
    the elements present in the HTML resource by the original name.

     * @param originalId The Id of the element present in the HTML resource
     * @param generatedId The self-generated Id value
     */
    private addDictionaryEntry(originalId: string, generatedId: string)
    {
        var entry = new ViewDictionaryEntry(originalId, generatedId);
        this.viewDictionary.push(entry);
    }


    /**
     * This function is triggered by WidgetFragment and is responsible 
     * for fetching the HTML resource in WebDir and linking it to this Widget. 
     * 
     * From here, all elements present in the HTML marked with some "Id" 
     * attribute will be made availableas DOM Elements to the inherited object when 
     * "onWidgetDidLoad()" is invoked
     * @param onloadNotifiable An Notifiable to receive a notification when the Widget is rendered
     */
    public renderView(onloadNotifiable: INotifiable)
    {
        var self = this;

        this.viewDictionary = [];

        var html: string = this.htmlTemplate();
        var parser = new DOMParser();
        var domObj = parser.parseFromString(html, "text/html");
        var allIds = domObj.querySelectorAll('*[id]');

        for (var i = 0; i < allIds.length; i++)
        {
            var element = allIds[i];
            var currentId = element.getAttribute('id');
            if (currentId != null)
            {
                var newId = `${currentId}_${Widget.generateUUID()}`;
                self.addDictionaryEntry(currentId, newId);
                element.setAttribute('id', newId);
            }
        }

        self.DOM = domObj;

        var child: ChildNode = domObj.documentElement.childNodes[1].firstChild;
        self.parentFragment.appendChildElementToContainer(child as Element);

        self.onWidgetDidLoad();
        onloadNotifiable.onNotified('FSWidget', [self, domObj]);
    }


    onNotified(sender: any, args: any[]): void { }

    /**
     * Public Domain/MIT
     * 
     * This function generates a UUID (universal unique identifier value) to bind to an HTML element
     */
    public static generateUUID()
    {
        var d = new Date().getTime();//Timestamp
        var d2 = ((typeof performance !== 'undefined') && performance.now && (performance.now() * 1000)) || 0;//Time in microseconds since page-load or 0 if unsupported
        var res = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c)
        {
            var r = Math.random() * 16;//random number between 0 and 16
            if (d > 0)
            {//Use timestamp until depleted
                r = (d + r) % 16 | 0;
                d = Math.floor(d / 16);
            } else
            {//Use microseconds since page-load if supported
                r = (d2 + r) % 16 | 0;
                d2 = Math.floor(d2 / 16);
            }
            var result = (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);

            return result;
        });

        return res.split('-')[0];
    }
}
/**
 * A WidgetContext is able to manage a 
 * set of widgets linked in a div
 * contained in a `ViewLayout`
 * 
 * This is automatically managed by the UIView, 
 * but new WidgetContext's can be dynamically 
 * created to manage another portion of Widgets 
 * located in other Divs.
 */
export class WidgetContext
{

    fragments: WidgetFragment[];
    messageProtocolFunction?: Function;
    fragmentsLoaded: number;
    notifiableView?: INotifiable; //based on FSView
    shellPage: PageShell;
    ctx: WidgetContext;
    contextLoaded: boolean = false;

    constructor(shellPage: PageShell,
        managedElementsIds: string[],
        messageProtocolFunction?: Function)
    {
        this.fragments = [];
        this.messageProtocolFunction = messageProtocolFunction;

        var self = this;
        self.shellPage = shellPage;

        for (var i = 0; i < managedElementsIds.length; i++)
        {
            var elementId = managedElementsIds[i];
            var divElement = shellPage.elementById(elementId) as HTMLDivElement;
            self.fragments.push(new WidgetFragment(self, divElement));
        }
    }
    contextShell(): PageShell
    {
        return this.shellPage;
    }

    findFragment(fragmentName: string): WidgetFragment
    {
        for (var i = 0; i < this.fragments.length; i++)
        {
            var fragment: WidgetFragment = this.fragments[i];
            if (fragment.fragmentId == fragmentName)
                return fragment;
        }
        return null as unknown as WidgetFragment;
    }

    findWidget(fragmentName: string, widgetName: string)
    {
        var fragment: WidgetFragment = this.findFragment(fragmentName);
        var widget: Widget = fragment.findWidget(widgetName);
        return widget;
    }

    pushMessage(widgetName: string, messageId: number, messageText: string, messageAnyObject: object)
    {
        if (this.messageProtocolFunction != null)
        {
            this.messageProtocolFunction(
                new WidgetMessage(
                    widgetName,
                    messageId,
                    messageText,
                    messageAnyObject
                )
            );
        }
    }

    /**
     * Attaches a Widget to a `WidgetFragment`.
     * A `WidgetFragment` is the direct controller of ONE 
     * div and can manage multiple Widgets related to this div
     */
    addWidget(fragmentName: string, widget: Widget)
    {
        var fragment = this.findFragment(fragmentName);
        fragment.attatchWidget(widget);

        if (this.contextLoaded)
        {
            fragment.renderFragmentwidgets();
        }

        return this;
    }

    getManagedWidgets(): Array<Widget>
    {
        try
        {
            var widgets: Array<Widget> = [];
            for (var frg = 0; frg < this.fragments.length; frg++)
            {
                var fragment: WidgetFragment = this.fragments[frg];
                for (var wdg = 0; wdg < fragment.widgets.length; wdg++)
                {
                    var widget: Widget = fragment.widgets[wdg];
                    widgets.push(widget);
                }
            }
            return widgets;
        } 
        catch(e)
        {
            return [];
        }
    }

    removeWidget(widget: Widget)
    {
        if (widget == null) return;
        var fragment = widget.getOwnerFragment();
        if (fragment == null) return;
        fragment.dettatchwidget(widget);
    }

    onFragmentLoad()
    {
        this.fragmentsLoaded += 1;
        if (this.fragmentsLoaded == this.fragments.length)
        {
            this.contextLoaded = true;
            if (this.notifiableView != null)
                this.notifiableView.onNotified('FSWidgetContext', []);
        }
    }

    /**
     * Performs the rendering of the Widgets attached to this Context.
     * Immediately orders the Fragments managed by this Context to draw 
     * the Widgets they manage.
     * @param notifiable 
     * @param clear 
     */
    build(notifiable?: INotifiable, clear: boolean = false)
    {
        this.fragmentsLoaded = 0;
        this.notifiableView = notifiable;

        for (var i = 0; i < this.fragments.length; i++)
        {
            var fragment: WidgetFragment = this.fragments[i];
            if (clear == true)
                fragment.clear();

            fragment.renderFragmentwidgets();
        }
    }
}
/**
 * An efficient system of data binding and object synchronization (aka 'ViewModel') 
 * with the User Interface
 * 
 * Voce 
 */
export class BindingContext<ViewModel>
{
    private _binders: Array<WidgetBinder> = [];
    private viewModelInstance: ViewModel;

    /**
     * This is a concrete class and you should instantiate it normally,
     * You must provide an instance of the ViewModel and the inherited UIView currently displayed. 
     * But ATTENTION you must do this INSIDE the onViewDidload() function of your UIView inherited class.
     * 
     * ```
     *  export class MyView extends UIView { 
     *     private binding: BindingContext<ModelType>; 
     *     ... 
     *     onViewDidload(): void { 
     *        //Here Widgets attached in UIView will be linked with `ModelType`
     *        this.binding = new BindingContext<ModelType>(new ModelType(), this); 
     *        ...
     *     }
     * ```
     * @param viewModel An instance of the ViewModel object
     * @param view UIView instance inherits class (the currently displayed UIView)
     */
    constructor(viewModel: ViewModel, view: UIView)
    {
        this.viewModelInstance = viewModel;
        this.scanViewModel(view);
    }


    /**
     * Gets a WidgetBinderBehavior from which the behavior of data bindings will be changed.
     * @param modelPropertyName The name of the property/key present in the ViewModelType type
     * @returns `WidgetBinderBehavior`
     */
    public getBindingFor(modelPropertyName: string): WidgetBinderBehavior
    {
        var propBinders: Array<WidgetBinder> = [];
        for (var i = 0; i < this._binders.length; i++)
        {
            var binder: WidgetBinder = this._binders[i];
            if (binder.modelPropertyName == modelPropertyName)
                propBinders.push(binder);
        }
        return new WidgetBinderBehavior(propBinders);
    }

    /**
     * Causes a UI refresh on all Widgets managed by this Data Binding Context
     * based on the current values of the properties/keys of the ViewModelType instance \
     * \
     * (remember that the ViewModelType instance is managed by this context as well)
     */
    public refreshAll(): void
    {
        for (var b = 0; b < this._binders.length; b++)
        {
            var binder: WidgetBinder = this._binders[b];
            binder.refreshUI();
        }
    }

    /**
     * Get an instance of `ViewModel` based on Widgets values
     * @returns `ViewModel`
     */
    public getViewModel<ViewModel>(): ViewModel
    {
        for(var i = 0; i < this._binders.length; i++)
          this._binders[i].fillPropertyModel();
        return this.viewModelInstance as unknown as ViewModel;
    }

    /**
     * Defines an instance of `ViewModel`.\
     * This causes an immediate UI refresh on all widgets managed by this context. \
     * \
     * You can also use this to reset (say 'clear') the Widgets state by passing a `new ViewModel()`
     * @param viewModelInstance `ViewModel` 
     * @returns 
     */
    public setViewModel(viewModelInstance: ViewModel): BindingContext<ViewModel>
    {
        this.viewModelInstance = viewModelInstance;
        for (var b = 0; b < this._binders.length; b++)
        {
            var binder: WidgetBinder = this._binders[b];
            binder.setModel(this.viewModelInstance, binder.modelPropertyName);
        }
        this.refreshAll();
        return this;
    }

    /**
     * Scans the Widgets managed in a UIView for matches with 
     * properties/keys present in the ViewModel type object 
     * managed by this Context
     */
    private scanViewModel(view: UIView): void
    {
        var self = this;
        var widgets: Array<Widget> = view.managedWidgets();
        if (widgets == null || widgets == undefined || widgets.length == 0)
            throw new Error("Illegal declaration: BindingContext cannot be initialized by the View's constructor. Consider instantiating it in onViewDidLoad()");

        for (var key in self.viewModelInstance)
        {
            for (var w = 0; w < widgets.length; w++)
            {
                var widget: Widget = widgets[w];
                var keyMatch: boolean = self.isModelPropertyMatchWithWidget(widget, key);
                if (keyMatch)
                    this.bindWidget(widget, key);
            }
        }
    }

    private isModelPropertyMatchWithWidget(widget: Widget, modelKey: string): boolean
    {
        var widgetName: string = widget.widgetName;
        if (widgetName.indexOf(modelKey) < 0) return false;
        var replaced: string = widgetName.replace(modelKey, '');
        var propLength: number = modelKey.length;
        var replacedLength: number = replaced.length;
        return (replacedLength < propLength);
    }

    private bindWidget(widget: Widget, modelKey: string): WidgetBinder
    {
        try
        {
            var binder: WidgetBinder = (widget as unknown as IBindable).getBinder();
            if (binder == null || binder == undefined)
                return null;

            binder.setModel(this.viewModelInstance, modelKey);
            this._binders.push(binder);
            return binder;
        } catch {
            return null;
        }
    }
}
/**
 * Implementing this interface will make a
 * Widget compatible with Data Binding features
 */
export interface IBindable
{
    /**
     * Produces an instance of the `WidgetBinder` implementation. 
     * This class is responsible for controlling the data binding 
     * flow for this Widget
     */
    getBinder(): WidgetBinder;
}
/**
 *  Allows you to define binding behaviors for a 
 * set of `WidgetBinder` 
 * classes that are bound to a property/key of 
 * the object-model being managed by the `BindingContext<T>`
 */
export class WidgetBinderBehavior
{
    private _binders: Array<WidgetBinder>;
    constructor(binders: Array<WidgetBinder>)
    {
        this._binders = binders;
    }

    /**
     * When data binding is done based on a list of model objects, 
     * it may be necessary to specify a binding path INSIDE that model 
     * object via its properties/keys.
     * 
     * This happens for example when binding a 
     * list of `'Contact'` in `UISelect` or `UIList`: 
     * although they are able to load an Array<Contact>, 
     * they won't know that they should use the prop/key 'Id' 
     * like selection value and the 'Name' prop/key as 
     * the display value.
     * @param displayPropertyName The prop/key on the model object that will be displayed in the control
     * @param valuePropertyName The prop/key in the model object that will be used as the selected value in the Widget
     */
    hasPath(displayPropertyName: string, valuePropertyName: string): WidgetBinderBehavior
    {
        for (var i = 0; i < this._binders.length; i++)
            this._binders[i].hasPath(displayPropertyName, valuePropertyName);
        return this;
    }

    /**
     * Set a target when you want the selected Widget 
     * value to be transferred to a given property/key 
     * in the same model-object.
     * @param targetValuePropertyName  Property/key in the model-class to which the selected Widget-value will be transferred.
     */
    hasTarget(targetValuePropertyName: string): WidgetBinderBehavior
    {
        for (var i = 0; i < this._binders.length; i++)
            this._binders[i].hasTarget(targetValuePropertyName);
        return this;
    }
}
/**
 * It acts as a bridge between the `BindingContext<T>` 
 * and the respective Widget. 
 * 
 * This allows the Widget to incorporate Data Binding 
 * functionality with model-objects.
 * 
 * If you have a custom `Widget` created in your project, 
 * you will need to provide a `WidgetBinder` implementation 
 * to provide Data Binding functionality
 */
export abstract class WidgetBinder
{
    abstract getWidgetValue(): any | object;
    abstract refreshUI(): void;
    abstract fillPropertyModel(): void;

    protected widget: Widget;
    public widgetName: string;
    private bindingName: string;

    private _viewModel: any | object;
    public modelPropertyName: string;
    private modelTargetPropertyName?: string;

    public bindingHasPath: boolean;
    public displayProperty: string;
    public valueProperty: string;

    constructor(widget: Widget) 
    {
        this.widget = widget;
        this.widgetName = widget.widgetName;
        this.bindingName = `${typeof (widget)}Binding ${this.widgetName} => ${typeof (widget)}`;
    }

    getModelPropertyValue(): any | object
    {
        if (this._viewModel == null || this.modelPropertyName == null || this.modelPropertyName == '')
            return null;
        var value = this._viewModel[this.modelPropertyName];
        return value;
    }

    setModelPropertyValue(value: any|object): void
    {
        if (this._viewModel == null || this.modelPropertyName == null || this.modelPropertyName == '')
            return;
        this._viewModel[this.modelPropertyName] = value;
    }

    toString(): string
    {
        return this.bindingName;
    }

    hasPath(displayPropertyName: string, valuePropertyName: string): WidgetBinder
    {
        this.bindingHasPath = true;
        this.displayProperty = displayPropertyName;
        this.valueProperty = valuePropertyName;
        this.refreshUI();
        return this;
    }

    hasTarget(targetValuePropertyName: string): WidgetBinder
    {
        this.modelTargetPropertyName = targetValuePropertyName;
        return this;
    }

    isTargetDefined(): boolean
    {
        return this.modelTargetPropertyName != null;
    }

    fillModelTargetPropertyValue(): void
    {
        if(this.isTargetDefined() == false) return;
        var value = this.getWidgetValue();
        this._viewModel[this.modelTargetPropertyName] = value;
    }

    getModelTargetPropertyValue(): any|object
    {
        if(this.isTargetDefined() == false) return;
        var value = this._viewModel[this.modelTargetPropertyName];
        return value;
    }

    setModel(viewModelInstance: any|object, propertyName: string): void
    {
        this._viewModel = viewModelInstance;
        this.modelPropertyName = propertyName;
        this.bindingName = `${typeof (this.widget)}Binding ${this.widgetName} => ${typeof (this.widget)}.${this.modelPropertyName}`;

        this.refreshUI();
    }
}
export class Bearer
{
    public static get(token: string): Headers
    {
        return new Headers({
            'content-type': 'application/json',
            'authorization': `Bearer ${token}`
        });
    }
}

export class APIResponse
{
    public statusCode: number;
    public statusMessage: string;
    public content: any | object;

    constructor({ code, msg, content }:
        {
            code: number,
            msg: string,
            content: any | object,
        })
    {
        this.statusCode = code;
        this.statusMessage = msg;
        this.content = content;
    }
}

/**
 * Offers an abstraction for consuming REST APIs with the 
 * possibility of simulating a local 
 * API for development purposes;
 * 
 * If your FrontEnd is not running alongside the API, 
 * be careful to call previously (once) 
 * ```
 * WebAPI.setURLBase('https://complete-url-of-api.com')
 * ``` 
 * 
 * Example: 
 * ```
WebAPI
.POST('/api/route/xyz') //.GET() / .PUT() / .DELETE()
.withBody(objectBodyHere) //if .POST() or .PUT()
.onSuccess(function (res: APIResponse){ 
    //success handle function
})
.onError(function(err: Error){
    //request-error handle function
})
.call(); //call REST api
 * ```
 */
export class WebAPI
{
    private static urlBase: string;
    public static setURLBase(apiUrlBase: string)
    {
        WebAPI.urlBase = apiUrlBase;
    }

    public static requestTo(requestString: string, httpMethod: string)
    {
        if (requestString.startsWith('http'))
            return new WebAPI(requestString, httpMethod);
        else
        {
            if (this.urlBase == '' || this.urlBase == undefined)
                return new WebAPI(`${requestString}`, httpMethod);
            else
                return new WebAPI(`${WebAPI.urlBase}${requestString}`, httpMethod);
        }
    }

    public static useSimulator(simulator: WebAPISimulator): void
    {
        WebAPI.simulator = simulator;
    }

    public static GET(requestString: string)
    {
        return this.requestTo(requestString, 'GET');
    }

    public static POST(requestString: string)
    {

        return this.requestTo(requestString, 'POST');
    }

    public static PUT(requestString: string)
    {
        return this.requestTo(requestString, 'PUT');
    }

    public static DELETE(requestString: string)
    {
        return this.requestTo(requestString, 'DELETE');
    }

    private request: RequestInit;
    private apiUrl: string;
    private fnOnSuccess: Function;
    private fnDataResultTo: Function;
    private fnOnError: Function;
    private static simulator: WebAPISimulator;

    private constructor(url: string, method: string)
    {
        this.request = {};
        this.request.method = method;
        this.apiUrl = url;
        this.withHeaders(new Headers({ 'content-type': 'application/json' }));
    }

    public call(): void
    {
        if (WebAPI.simulator == null)
        {
            var statusCode: number;
            var statusMsg: string;
            var self = this;

            fetch(self.apiUrl, self.request)
                .then(function (ret: Response)
                {
                    statusCode = ret.status;
                    statusMsg = ret.statusText;
                    return ret.text();
                })
                .then(function (text: string)
                {
                    var json: any | object = null;
                    if (text.startsWith("{") || text.startsWith("["))
                        json = JSON.parse(text);

                    var apiResponse = new APIResponse({
                        code: statusCode, msg: statusMsg, content: json
                    });

                    return apiResponse;
                })
                .then(function (res: APIResponse)
                {
                    if (self.fnOnSuccess != null)
                        self.fnOnSuccess(res);
                    if(self.fnDataResultTo != null)
                    {
                        if(res.statusCode == 200)
                        {
                            var data = res.content;
                            self.fnDataResultTo(data);
                        }
                    }
                })
                .catch(err => (self.fnOnError == null ? {} : self.fnOnError(err)));
        }
        else
        {
            try
            {
                var result = WebAPI.simulator.simulateRequest(
                    this.request.method,
                    this.apiUrl.replace(WebAPI.urlBase, ''),
                    this.request.body);

                this.fnOnSuccess(result);
            } catch (error)
            {
                this.fnOnError(error);
            }
        }
    }

    public dataResultTo(callBack: Function): WebAPI
    {
        this.fnDataResultTo = callBack;
        return this;
    }

    public onSuccess(callBack: Function): WebAPI
    {
        this.fnOnSuccess = callBack;
        return this;
    }

    public onError(callBack: Function): WebAPI
    {
        this.fnOnError = callBack;
        return this;
    }

    public withAllOptions(requestInit: RequestInit): WebAPI
    {
        this.request = requestInit;
        return this;
    }

    public withBody(requestBody: any | object): WebAPI
    {
        this.request.body = JSON.stringify(requestBody);
        return this;
    }

    public withHeaders(headers: Headers): WebAPI
    {
        this.request.headers = headers;
        return this;
    }
}
export class SimulatedAPIRoute
{
    private method: string;
    private resource: string;
    private endPoint: Function;

    constructor(resource: string, method: string, endPoint: Function)
    {
        this.method = method;
        this.resource = resource;
        this.endPoint = endPoint;
    }

    public getMethod()
    {
        return this.method;
    }

    public getResource()
    {
        return this.resource;
    }

    public simulateRoute({ body = null, params = null }:
        {
            body?: any | object,
            params?: Array<string>
        }): any
    {
        if (this.method == 'GET' || this.method == 'DELETE')
        {
            return this.endPoint(params);
        }
        else
            return this.endPoint(body);
    }

    public toString()
    {
        return `[${this.method}] ${this.resource}`;
    }
}

/**
 * Allows you to simulate a REST API locally based on an 
 * API that may not yet exist, but will respond for the routes
 * that are defined in the Simulator.
 * 
 * You must inherit this class and define it in
    ```
    WebAPI.useSimulator(new MyAPISimulatorImpl());
    ```
 */
export abstract class WebAPISimulator
{
    private simulatedRoutes: Array<SimulatedAPIRoute> = [];

    /**
     * Maps a simulated route to which this 
     * Simulator should respond when 
     * ```
     *WebAPI.call()
     * ``` 
     * is invoked
     * 
     * @param httpMethod 'GET' / 'POST' / 'PUT' / 'DELETE'
     * @param resource The resource name or endpoint path that the real API would have
     * @param endPoint A function (callback) that should respond for the resource endpoint 
     *
     * Function definition should follow these standards:
     * 
     * **for GET/DELETE routes** - 
     *  ```
     * functionEndpointName(params: Array<string>): any|object
     * ```
     *                   
     * **for POST/PUT routes** 
     * ```
     * functionEndpointName(body: any|object): any|object
     * ```
     */
    protected mapRoute(httpMethod: string, resource: string, endPoint: Function): WebAPISimulator
    {
        this.simulatedRoutes.push(new SimulatedAPIRoute(resource, httpMethod, endPoint));
        return this;
    }

    /**
     * Fires a request originating from the `WebAPI` 
     * class and redirected to the Simulator,
     * which will respond by calling 
     * a "fake-endpoint" function
     */
    public simulateRequest(
        httpMethod: string,
        resource: string,
        body: any | object): any | object
    {
        for (var i = 0; i < this.simulatedRoutes.length; i++)
        {
            const route: SimulatedAPIRoute = this.simulatedRoutes[i];
            const isResource = resource.startsWith(route.getResource());
            const isMethod = httpMethod == route.getMethod();

            if (isResource && isMethod)
            {
                if (route.getMethod() == 'GET' || route.getMethod() == 'DELETE')
                {
                    const path = resource.replace(route.getResource(), '');
                    var params = path.split('/');
                    if (params.length > 0)
                        if (params[0] == '')
                            params = params.splice(-1, 1);
                    return new APIResponse({
                        code: 200,
                        msg: 'fetched from API Simulator',
                        content: route.simulateRoute({ params })
                    });
                }

                if (route.getMethod() == 'POST' || route.getMethod() == 'PUT')
                {
                    return new APIResponse({
                        code: 200,
                        msg: 'fetched from API Simulator',
                        content: route.simulateRoute({ body: JSON.parse(body) })
                    })
                }
                break;
            }
        }
    }
}
/**
 * Initialization options for div-columns
 */
export class ColOptions
{
    colClass?: string;
    colHeight?: string;
    rows?: Row[];
}


/**
 * Represents a Column-Div with standard Bootstrap classes and a height of 100px
 */
export class Col
{
    id: string;
    colClass?: string = 'col-lg-12 col-md-12 col-sm-12 col-sm-12';
    colHeight?: string = '100px';
    columnRows?: Row[] = [];

    /**
     * 
     * @param id The 'Id' attribute that the resulting div will have
     * @param options 
     */
    constructor(id: string, options?: ColOptions)
    {
        this.id = id;

        if (options != null)
        {
            if (Misc.isNullOrEmpty(options.colHeight) == false)
                this.colHeight = options.colHeight;

            if (Misc.isNullOrEmpty(options.colClass) == false)
                this.colClass = options.colClass;

            if (options.rows !== null)
                this.columnRows = options.rows;
        }
    }
}
/**
 * A standard implementation for `ILayoutPresenter`
 */
export class DefaultLayoutPresenter implements ILayoutPresenter
{
    presenter: DefaultLayoutPresenter;
    private pageShell: PageShell;

    constructor()
    {
        this.presenter = this;
    }


    renderLayout(layout: ViewLayout, pageShell: PageShell): Element
    {
        this.pageShell = pageShell;
        var parentContainer: HTMLDivElement = layout.containerDivObj as HTMLDivElement;

        if (parentContainer == null) return null;

        parentContainer.innerHTML = '';
        // parentContainer.style.opacity = '0';

        for (let rowIndex = 0; rowIndex < layout.layoutRows.length; rowIndex++)
        {
            var rowObj: Row = layout.layoutRows[rowIndex];
            var rowView = this.renderRow(rowObj);
            parentContainer.appendChild(rowView);
        }

        return parentContainer;
    }

    private renderRow(row: Row): HTMLDivElement
    {

        //creates master row div
        const rowDiv: HTMLDivElement = document.createElement("div");
        if (row.rowClass != null && row.rowClass != undefined)
        {
            const classes: Array<string> = row.rowClass.split(' ');
            for (var i = 0; i < classes.length; i++)
            {
                const className = classes[i].trim();
                if (className == '') continue;
                rowDiv.classList.add(className);
            }
        }

        rowDiv.id = row.id;
        rowDiv.style.height = row.rowHeidth;

        if (row.rowColumns != null)
        {
            for (let index = 0; index < row.rowColumns.length; index++)
            {
                const column: Col = row.rowColumns[index];

                //an sub-div column
                const colDiv: HTMLDivElement = document.createElement("div");

                if (Misc.isNullOrEmpty(column.colClass) == false)
                {
                    const classes: Array<string> = column.colClass.split(' ');
                    for (var i = 0; i < classes.length; i++)
                    {
                        const className = classes[i].trim();
                        if(className == '') continue;
                        colDiv.classList.add(className);
                    }
                }

                colDiv.id = column.id;
                colDiv.style.height = column.colHeight;

                rowDiv.appendChild(colDiv);

                if (column.columnRows != null)
                {
                    for (let subRowIndex = 0; subRowIndex < column.columnRows.length; subRowIndex++)
                    {
                        //sub-div column has rows
                        const columnSubRow = column.columnRows[subRowIndex];

                        //recursivelly call renderRow() again,
                        const subRowElement = this.renderRow(columnSubRow);

                        //then catch Element result and append it to sub-div column (aka "colDiv")

                        if (subRowElement != null)
                            colDiv.appendChild(subRowElement);
                    }
                }
            }
        }
        return rowDiv;
    }
}
/**
 * Implementing this interface in a common 
 * class will allow an isolated point of 
 * customization of a given Widget
 * 
 * You should transfer the instance of this 
 * implementation to the `setCustomPresenter()` 
 * function in the `Widget` object
 */
export interface ICustomWidgetPresenter<TWidget>
{
    render(widget: TWidget) : void;
}
/**
 * A layout presenter's role is to read and 
 * transform into reality (DOM Div's components) the data 
 * of the `ViewLayout` class whose instance is provided 
 * by the `UIView` inherited class
 */
export interface ILayoutPresenter {
    renderLayout(layout: ViewLayout,  pageShell: PageShell):Element;
}
/**
 * Represents a notifiable object. Initially it is used by the 
 * WidgetContext to notify data to the UIView. \
 * But it can be used generically for any purpose.
 */
export interface INotifiable
{
    /**
     * Notifies the target class that implements this contract
     * @param sender A name-id of whoever is sending this
     * @param args  Miscellaneous arguments and parameters (it is up to the notification receiver to handle this)
     */
    onNotified(sender: any, args: Array<any>): void;
}
export interface ISplittableView
{

    onConnectViews(splitOwner: ISplittableView): void;
    onSplittedViewRequestExpand(send: UIView): void;
    onSplittedViewRequestShrink(send: UIView): void;
    onSplittedViewRequestClose(send: UIView): void;
    onSplittedViewDataReceive(dataScope: string, args: any, send: UIView): void;
    onSplittedViewDataRequest(dataScope: string, args: any, send: UIView): any;
}
/**
 * Used to do library imports (reference CSS and JavaScript) in a single function. 
 * 
 * A few JavaScript libraries may not work properly 
 * due to the way your code initializes them.
 * At this time, you should resort to 
 * `<script />` import directly into 
 * the .HTML page.
 */
export class NativeLib
{
    libName: string;
    hasCss: boolean;
    hasJs: boolean;

    private cssPath: string;
    private jsPath: string;

    /**
     * Library to be imported.\
     * NOTE!!!: the root-path considered here is `'/lib/'` and this is determined by the static variable `PageShell.LIB_ROOT`
     * @param libName The library folder itself 
     * @param cssPath The name (or subpath) of the library's .css file. If not, ignore this parameter.
     * @param jsPath The name (or subpath) of the library's .js file. If not, ignore this parameter.
     */
    constructor({ libName, cssPath = '', jsPath = '' }: {
        libName: string;
        cssPath?: string;
        jsPath?: string;
    })
    {
        this.libName = libName;
        this.cssPath = cssPath;
        this.jsPath = jsPath;
        this.hasCss = (cssPath != '' && cssPath != null);
        this.hasJs = (jsPath != '' && jsPath != null);
    }

    
    public getCssFullPath(): string
    {
        return `${PageShell.LIB_ROOT}${this.libName}/${this.cssPath}`;
    }
    public getJsFullPath(): string
    {
        return `${PageShell.LIB_ROOT}${this.libName}/${this.jsPath}`;
    }
    public toString(): string
    {
        return this.libName;
    }
}
/**
 * PageShell is a class that works at the lowest level (next to the page)
 * and performs some tasks in the DOM interface such as 
 * creating/finding/removing elements, 
 * directly importing native JS-CSS libraries 
 * and controlling access to resources such as SplitView, Storage and others.
 */
export class PageShell
{

    /**defaults: '/lib/' */
    public static LIB_ROOT = '/lib/'

    private baseDocument: Document;
    public importedLibs: NativeLib[];
    private page: UIPage;

    private appStorageProvider: IAppStorageProvider = null;

    private appContainer: HTMLDivElement;
    private splitContainer: HTMLDivElement;

    constructor(mainDocument: Document, fsPage: UIPage) 
    {
        this.baseDocument = mainDocument;
        this.importedLibs = [];
        this.page = fsPage;
    }

    /**
     * Called from the `UIPage` implementation, 
     * enables the Storage feature, 
     * indicating a implementation of the `IAppStorageProvider` interface
     * @param provider 
     */
    public setStorageProvider(provider: IAppStorageProvider): void
    {
        this.appStorageProvider = provider;
    }

    /**
     * Called from the UIView or other high consumer-classes, requests an instance of `AppStorage` 
     * which must be resolved by the implementation of `IAppStorageProvider` 
     * (usually the same one that implements `UIPage`)
     * @param type `'local'` to LocalStorage or `'session'` to  SessionStorage
     * @param schemaName A unique name to demarcate a data context
     * @returns `AppStorage` instance
     */
    public requestStorage(type: string, schemaName: string): AppStorage
    {
        return this.appStorageProvider.onStorageRequested(type, schemaName);
    }

    /**
     * Enables the SplitView feature and allows two 
     * UIViews to be loaded simultaneously side-by-side on the page.
     * 
     * You must have marked this `<div id="app/split" />` previously in your HTML file.
     * 
     * @param appContainerId Id of the page's main app container div. The div that will display most UIView's in your app
     * @param splitContainerId Split container div id. The secondary UIView will be loaded in this Div
     */
    public enableSplitting(appContainerId: string, splitContainerId: string): void
    {
        this.appContainer = this.elementById(appContainerId) as HTMLDivElement;
        this.splitContainer = this.elementById(splitContainerId) as HTMLDivElement;

        if (this.splitContainer == null)
            throw new Error(`enable split fail: container Id '${splitContainerId}' not found in document. An div tag with this Id maybe not present.`);

        this.splitContainer.style.width = '0 px';
        this.splitContainer.hidden = true;
    }

    private currentViewSplitted: boolean = false;

    /**
     * Determines if SplitView is currently active
     */
    public isViewSplitted(): boolean
    {
        return this.currentViewSplitted;
    }

    /**
     * Sets the currently Splitted UIView to a reduced size
     * This will only work if `PageShell.isViewSplitted()` is `true`.
     */
    public shrinkSplitView()
    {
        if (this.currentViewSplitted == false) return;

        var self = this;
        this.splitContainer.hidden = false;
        var interv = setInterval(function ()
        {
            self.appContainer.classList.remove('col-6');
            self.appContainer.classList.add('col-9');

            self.splitContainer.classList.remove('col-6');
            self.splitContainer.classList.add('col-3');
            clearInterval(interv);
        });
        this.currentViewSplitted = true;

        self.splitContainer.style.borderLeft = '3px solid gray';
    }

    /**
     * Sets the currently Splitted UIView to a side-by-side size (50%)
     */
    public expandSplitView()
    {
        if (this.currentViewSplitted == false) return;

        var self = this;
        this.splitContainer.hidden = false;
        var interv = setInterval(function ()
        {
            self.appContainer.classList.remove(...self.appContainer.classList);
            self.appContainer.classList.add('col-6');

            self.splitContainer.classList.remove(...self.splitContainer.classList);
            self.splitContainer.classList.add('col-6');
            clearInterval(interv);
        });
        this.currentViewSplitted = true;

        self.splitContainer.style.borderLeft = '3px solid gray';
    }

    /**
     * Initializes a new UIView alongside the currently displayed UIView via SplitView features
     * @param ownerSplitView UIView currently displayed
     * @param splittedCallingView  New UIView that will be displayed next to the current one
     */
    public requestSplitView(ownerSplitView: ISplittableView, splittedCallingView: UIView): void
    {
        if (this.currentViewSplitted) return;

        var self = this;
        this.splitContainer.hidden = false;
        var interv = setInterval(function ()
        {
            self.appContainer.classList.remove(...self.appContainer.classList);
            self.appContainer.classList.add('col-9');
            clearInterval(interv);
        });
        this.currentViewSplitted = true;

        self.splitContainer.style.borderLeft = '3px solid gray';
        this.navigateToView((splittedCallingView as unknown) as UIView);

        (splittedCallingView as unknown as ISplittableView).onConnectViews(ownerSplitView);
    }

    /**
     * Fully collapse the SplitView Div and destroy the currently used UIView with Split
     */
    public closeSplitView()
    {
        if (this.currentViewSplitted == false) return;

        var self = this;
        this.splitContainer.innerHTML = '';
        this.splitContainer.hidden = true;
        var interv = setInterval(function ()
        {
            self.splitContainer.classList.remove(...self.splitContainer.classList);
            self.splitContainer.classList.add('col-3');

            self.appContainer.classList.remove(...self.appContainer.classList);

            self.appContainer.classList.add('col-12');
            clearInterval(interv);
        });
        this.currentViewSplitted = false;

    }

    /**
     * Creates (say "instance") a new HTMLElement object that represents an original HTML tag with its properties and attributes
     * @param tagName The exact name of the desired HTML5 tag
     * @param innerText (Optional) an initial text inserted as tag content (if the html element supports it)
     * @returns 
     */
    public createElement<K extends keyof HTMLElementTagNameMap>(tagName: K, innerText?: string)
    {
        var element = this.baseDocument.createElement(tagName);
        if (innerText != null)
            element.innerText = innerText;
        return element;
    }

    /**
     * Renders and brings to the front a view generated by a UIView object
     * @param view 
     */
    public navigateToView(view: UIView): void
    {
        this.page.navigateToView(view);
    }

    /**
     * Get the `<body>` of the page
     * @returns 
     */
    public getPageBody(): Element
    {
        return this.elementsByTagName('body')[0];
    }

    public elementsByTagName(tagName: string): HTMLCollectionOf<Element>
    {
        return this.baseDocument.getElementsByTagName(tagName);
    }

    public elementById(elementId: string): Element
    {
        return this.baseDocument.getElementById(elementId);
    }

    public appendChildToElement(containerElement: Element, childElement: Element): Element
    {
        return containerElement.appendChild(childElement);
    }

    public removeChildFromElement(containerElement: Element, childElement: Element): Element
    {
        return containerElement.removeChild(childElement);
    }

    public getImportedLib(libName: string): NativeLib
    {
        if (this.importedLibs == undefined) return;
        for (var i = 0; i < this.importedLibs.length; i++)
            if (this.importedLibs[i].libName == libName)
                return this.importedLibs[i];
        return null;
    }

    /**
     * Import a native JS-CSS library into the page, 
     * specifying the name and paths to the 
     * .js and .css content files
     */
    public import(lib: NativeLib): void
    {
        var existing = this.getImportedLib(lib.libName);
        if (existing !== null)
            return;

        if (lib.hasCss)
        {
            var link: HTMLLinkElement = document.createElement('link');
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = lib.getCssFullPath();

            document.head.appendChild(link);
        }

        if (lib.hasJs)
        {
            var jsImport: HTMLScriptElement = document.createElement('script');
            jsImport.src = lib.getJsFullPath();

            document.body.appendChild(jsImport);
        }

        this.importedLibs.push(lib);
    }
}
export class RowOptions
{
    rowHeidth?: string;
    rowClass?: string;

    columns?: Col[] = [];

    constructor()
    {
        this.rowClass = 'row';
    }
}


/**
 * Represents a Row Div with standard Bootstrap class options
 */
export class Row
{
    id: string;
    rowClass: string = 'row';
    rowWidth: string;
    rowHeidth: string;
    flexGrow1: boolean;
    rowColumns: Col[] = [];

    generatedColumnId: string;

    /**
     * 
     * @param id A div-container Id to parent this
     * @param options Row options like class, height and sub-columns; NOTE: if no column is provided, it may be that at least 
     * one column is generated automatically. To determine this, 
     * check the static variable `ViewLayout.AUTO_GENERATE_COLUMNS`
     */
    constructor(id: string, options: RowOptions)
    {
        this.id = id;

        if (Misc.isNullOrEmpty(options.rowClass) == false)
            this.rowClass = options.rowClass;
        if (Misc.isNullOrEmpty(options.rowHeidth) == false)
            this.rowHeidth = options.rowHeidth;
        if (Misc.isNull(options.columns) == false)
            this.rowColumns = options.columns;

        if ((this.rowColumns == null || this.rowColumns == undefined) || this.rowColumns.length == 0)
        {
            if (ViewLayout.AUTO_GENERATE_COLUMNS)
            {
                var id: string = `col_${Widget.generateUUID()}`;
                this.generatedColumnId = id;
                this.rowColumns = [
                    new Col(id, { colClass: 'col-md-12 col-xs-12 col-lg-12 col-sm-12' })
                ];
            }
        }
        else
        {
            for (var i = 0; i < this.rowColumns.length; i++)
            {
                var column: Col = this.rowColumns[i];
                if (Misc.isNullOrEmpty(column.colClass))
                    column.colClass = 'col-md-12 col-xs-12 col-lg-12 col-sm-12'
            }
        }
    }
}
export class Misc 
{
    public static isNull(value: any|object): boolean
    {
        return (value == null || value == undefined);
    }

    public static isNullOrEmpty(value: any|object): boolean
    {
        return (value == null || value == undefined || value == '');
    }
}
/**
 * A common abstraction for local storage features, 
 * which can be persistent (aka 'LocalStorage') 
 * or temporary (aka 'SessionStorage')
 * */
export abstract class AppStorage
{
    protected type: string;
    protected schemaName: string;

    /**
     * To provide a concrete instance of this class, 
     * you must first implement `IAppStorageProvider` 
     * from your inherited `UIPage` class.
     * 
     * @param type 'local' or 'session'
     * @param schemaName A unique name to demarcate a data context
     */
    constructor(type: string, schemaName: string)
    {
        this.type = type;
        this.schemaName = schemaName;
    }

    /**
     * Writes a value to the Storage system. 
     * It is possible to send single data or entire objects
     * 
     * @param key A unique data identifier key
     * @param value The data itself. You can provide a simple value as a number or any text. But you can also send an entire object instance here.
     */
    public abstract write(key: string, value: any | object): void;

    /**
     * Updates a value in the storage system
     * 
     * @param key A unique data identifier key
     * @param value The data itself. You can provide a simple value as a number or any text. But you can also send an entire object instance here.
     */
    public abstract update(key: string, value: any | object): void;

    /**
     * Erases a value in the storage system
     * 
     * @param key A unique data identifier key
     */
    public abstract erase(key: string): void;

    /**
     * Retrieve a value in the storage system
     * 
     * @param key A unique data identifier key
     */
    public abstract get(key: string): any | object;
}
/**
 * Implementing this interface in an inherited `UIPage` 
 * class will enable the Storage feature in your application. 
 * 
 * The purpose of this interface is to provide an instance of the 
 * implementation of the `AppStorage` class
 */
export interface IAppStorageProvider
{
    /**
     * Implementing this interface will provide 
     * local and session storage capabilities 
     * for your app
     * 
     * It will occur when any UIView requests this feature.
     * You must return an implementation instance of `AppStorage`
     *
     * By default, you can use `RhabooStorageWrapper` implementation 
     * which is provided by Objective-UI library
     * 
     * Example: 
     * 
     * ```
    onStorageRequested(type: string, schemaName: string): AppStorage
    {
        return new RhabooStorageWrapper(type, schemaName);
    }
     * ```
     * 
     * @param type `'local'` to LocalStorage or `'session'` to  SessionStorage
     * @param schemaName A unique name to demarcate a data context
     */
    onStorageRequested(type: string, schemaName: string): AppStorage;
}
export class RhabooInstance
{
    public name: string = null;
    public instance: any | object = null;
}

export class RhabooStorageWrapper extends AppStorage
{
    public static INSTANCES: Array<RhabooInstance> = [];

    public static addInstance(instance: RhabooInstance): void
    {
        RhabooStorageWrapper.INSTANCES.push(instance);
    }

    private rhaboo: RhabooInstance;


    /**
     *  REQUIRED `<script src="lib/rhaboo/rhaboo.js"></script>`
     * 
     * 
     * This is an implemented portability of "Rhaboo" (https://github.com/adrianmay/rhaboo), 
     * a powerful JavaScript library that allows storing 
     * object graphs (with references) in 
     * LocalStorage or SessionStorage with great 
     * precision and consistency.
     */
    constructor(type: string, schemaName: string)
    {
        super(type, schemaName);

        var rhabooInstanceType = (type == 'local' ? 'persistent' : 'perishable');
        var activate = new VirtualFunction({
            fnName: 'rhabooInstance',
            fnContent: `
                var rb = Rhaboo.${rhabooInstanceType}('${schemaName}');
                RhabooStorageWrapper.addInstance({ name: '${schemaName}', instance: rb });
            `
        });
        activate.call();

        for (var i = 0; i < RhabooStorageWrapper.INSTANCES.length; i++)
        {
            var instance = RhabooStorageWrapper.INSTANCES[i];
            if (instance.name == schemaName)
            {
                this.rhaboo = instance;
                break;
            }
        }
    }

    public write(key: string, value: any): void
    {
        this.rhaboo.instance.write(key, value);
    }
    public update(key: string, value: any): void
    {
        this.erase(key);
        this.write(key, value);
    }
    public erase(key: string): void
    {
        this.rhaboo.instance.erase(key);
    }
    public get(key: string): any | object
    {
        return this.rhaboo.instance[key];
    }
}
export class SelectOption
{
    public value: any;
    public text: string;

    constructor(opValue: any, opText: string)
    {
        this.value = opValue;
        this.text = opText;
    }
}
export class ViewDictionaryEntry 
{
    originalId : string;
    managedId : string;

    constructor(originalId : string, managedId : string) {
        this.originalId = originalId;
        this.managedId = managedId;
    }

    getOriginalId() {
        return this.originalId;
    }

    getManagedId() {
        return this.managedId;
    }
}
/**
 * ViewLayout is a class that logically contains a demarcation 
 * of divs that will be used by the UIView inherited class, 
 * when this View is rendered. \
 * \
 * It is possible to build the layout in the form of an object:
 * ```
new ViewLayout('app', [
    new Row('row-X', { rowClass: 'row', rowHeidth: '100px', 
        columns: [
            new Col('col-Y-left', { colClass: 'col-8',  colHeight: '80px' }),
            new Col('col-Y-right', { colClass: 'col-4', colHeight: '20px' )
        ]
    }),
])
 * ``` 
 * attributes are optional but can take on unwanted default values.
 *
 * Or directly by a raw-html string:  
 * 
 * ```
new ViewLayout('app').fromHTML(`
    <div class="row-x" style="height:100px">
        <div id="col-Y-left"  class="col-8"  style="height:80px"> </div>
        <div id="col-Y-right" class="col-4" style="height:20px"> </div>
    </div>
`);
 * ```
 */
export class ViewLayout
{
    public static AUTO_GENERATE_COLUMNS = false;

    
    private layoutDOM: Document;
    public layoutRows: Row[];
    public containerDivObj: Element;
    private containerDivName: string;
    private rawHtml: string;
    private fromString: boolean = false;

    private layoutPresenter: ILayoutPresenter = new DefaultLayoutPresenter();

    /**
     * 
     * @param containerDivId Provide the 'Id' of the Div that will contain this layout (and consequently the Widgets elements)
     * @param rows Provide root rows for this layout. Ignore this parameter if you want to provide the layout from raw-html content (via `ViewLayout().fromHTML()`)
     */
    constructor(containerDivId: string, rows?: Row[])
    {
        this.layoutRows = rows;
        this.containerDivName = containerDivId;
    }

    public getRow(rowId: string): Row
    {
        if (this.fromString)
            throw new Error('getRow() is not supported when layout is output over raw html string');

        for (var i = 0; i < this.layoutRows.length; i++)
            if (this.layoutRows[i].id == rowId)
                return this.layoutRows[i];
        return null as unknown as Row;
    }

    fromHTML(rawHtmlLayoutString: string): ViewLayout
    {
        this.fromString = true;
        this.rawHtml = rawHtmlLayoutString;
        return this;
    }

    render(shellPage: PageShell, customPresenter?: ILayoutPresenter): Element
    {
        this.containerDivObj = shellPage.elementById(this.containerDivName);

        if (this.fromString)
        {
            var parser = new DOMParser();
            var dom: Document = parser.parseFromString(this.rawHtml, 'text/html');
            this.layoutDOM = dom;
            this.containerDivObj.innerHTML = '';
            var objDom = this.layoutDOM.children[0].children[1];

            for (var i = 0; i < objDom.childNodes.length; i++)
                this.containerDivObj.appendChild(objDom.childNodes[i]);

            return objDom;
        }

        if (undefined == shellPage || null == shellPage)
            throw 'PageShell instance is required here.';
        if (undefined != customPresenter || null != customPresenter)
            this.layoutPresenter = customPresenter;

        return this.layoutPresenter.renderLayout(this, shellPage);
    }

    ElementsIdCollection(): string[]
    {
        if (this.fromString)
        {
            var idCollection: Array<string> = [];
            var nodesWithId: NodeListOf<Element> = this.containerDivObj.querySelectorAll('*[id]');
            for (var i = 0; i < nodesWithId.length; i++)
                idCollection.push(nodesWithId[i].id);
            return idCollection;
        }
        return this.ScanRows(this.layoutRows);
    }

    private ScanRows(rows: Row[]): string[]
    {
        var result: string[] = [];
        if (rows !== undefined)
        {
            for (var i = 0; i < rows.length; i++)
            {
                var row: Row = rows[i];
                result.push(row.id);

                if (row.rowColumns !== undefined)
                {
                    var cols: string[] = this.ScanColumns(row.rowColumns);
                    for (var c = 0; c < cols.length; c++)
                        result.push(cols[c]);
                }
            }
        }
        return result;
    }

    private ScanColumns(columns: Col[]): string[]
    {
        var result: string[] = [];
        for (var i = 0; i < columns.length; i++)
        {
            var col = columns[i];
            result.push(col.id);

            if (col.columnRows !== null)
            {
                var rows: string[] = this.ScanRows(col.columnRows);
                for (var r = 0; r < rows.length; r++)
                    result.push(rows[r]);
            }
        }
        return result;
    }
}
/**
 * The WidgetFragment has the ability to "draw" Widget objects 
 * into a LayoutId (html div) of the page. It is under the control 
 * of a WidgetContext and can manage several child Widgets.
 * 
 * It is also capable of attaching and detaching Widgets,
 * brokering message requests sent by child-Widgets 
 * and submitting them to its own-WidgetContext.
 * 
 */
export class WidgetFragment implements INotifiable
{

    contextRoot: WidgetContext;
    fragmentId: string;
    containerElement: HTMLDivElement;
    widgets: Widget[];
    widgetsLoaded: number;

    /**
     * 
     * @param appContextRoot The parent WidgetContext
     * @param containerElement An (Element object) HTML element to compose the adjacent Widgets. Usually Div's.
     */
    constructor(appContextRoot: WidgetContext, containerElement: HTMLDivElement)
    {
        this.contextRoot = appContextRoot;
        this.fragmentId = containerElement.getAttribute('id');

        //div object (not id)
        this.containerElement = containerElement;
        this.widgets = [];
    }

    clear()
    {
      this.containerElement.innerHTML = '';
    }

    /**
     * Submit a message request sent by the Widget directed to the parent-Context
     * @param widgetName The widget instance-name
     * @param messageId An "ID" of the message. The Widget may have its own message ID catalog for its respective handling cases.
     * @param messageText A text for the message
     * @param messageAnyObject Any object defined by the Widget itself. There are no restrictions on the object type.
     */
    pushMessageToRoot(
        widgetName: string,
        messageId: number,
        messageText: string,
        messageAnyObject: object): void
    {

        this.contextRoot.pushMessage(widgetName,
            messageId,
            messageText,
            messageAnyObject);
    }

    /**
     * Gets an Widget object instance
     * @param name Widget Instance Name
     * @returns Widget
     */
    findWidget(name: string): Widget
    {
        for (var i = 0; i < this.widgets.length; i++)
        {
            var widget: Widget = this.widgets[i];
            if (widget.widgetName == name)
                return widget;
        }

        return null;
    }

    /**
     * (Internal) method responsible for controlling the 
     * Widgets loading stack, and immediately notifying 
     * the parent-Context when the stack is
     * terminated.
     */
    private onWidgetLoad()
    {
        this.widgetsLoaded += 1;
        if (this.widgetsLoaded == this.widgets.length) //stack is end
            this.contextRoot.onFragmentLoad(); //notify to parent-ctx: "all Widgets been loaded :)""
    }

    resetFragment(): void
    {
        this.containerElement.innerHTML = '';
    }

    /**
     * Renders the Child Widgets stack on the specified Container
     */
    renderFragmentwidgets()
    {
        this.widgetsLoaded = 0;

        if (this.widgets.length == 0)
            this.contextRoot.onFragmentLoad();
        else
        {
            var self = this;
            var shell: PageShell = this.contextRoot.contextShell();

            self.containerElement.style.opacity = '0';

            for (var i = 0; i < self.widgets.length; i++)
            {
                var widget = self.widgets[i];
                widget.renderView(this as INotifiable);
            }

            var opacity = 0;
            var interv =     setInterval(function(){
                if (opacity < 1)
                {
                    opacity = opacity + 0.070
                    self.containerElement.style.opacity = opacity.toString();
                }
                else clearInterval(interv);
            });
        }
    }

    onNotified(sender: any, args: any[]): void
    {
        if (sender == 'FSWidget')
            this.onWidgetLoad();
    }

    /**
     * Attach a Widget to the Fragment
     * @param widget An Widget object
     */
    attatchWidget(widget: Widget)
    {
        for (var i = 0; i < this.widgets.length; i++)
        {
            var existingWidget: Widget = this.widgets[i];
            if (widget.widgetName == existingWidget.widgetName)
                throw `widget '${widget.widgetName}' has already been attached to this context.`;
        }

        widget.setParentFragment(this);
        this.widgets.push(widget);
    }

    /**
     * Detach a Widget from the Fragment
     * @param widget An Widget object 
     */
    dettatchwidget(widget: Widget): void
    {
        var toRemove = -1;
        for (let index = 0; index < this.widgets.length; index++)
        {
            var existingWidget: Widget = this.widgets[index];
            if (existingWidget.widgetName == widget.widgetName)
            {
                toRemove = index;
                break;
            }
        }

        if (toRemove > -1)
        {
            this.widgets.splice(toRemove, 1);
            this.containerElement.removeChild(widget.getDOMElement());
            widget.onWidgetDetached();
        }
    }

    appendChildElementToContainer(elementChild: Element)
    {
        this.contextRoot.contextShell().appendChildToElement(
            this.containerElement,
            elementChild
        );
    }
}
export class WidgetMessage
{
    widgetName: string;
    messageId: number;
    messageText: string;
    messageAnyObject: object;

    constructor(widgetName: string, 
        messageId: number, 
        messageText: string, 
        messageAnyObject: object)
    {
        this.widgetName = widgetName;
        this.messageId = messageId;
        this.messageText = messageText;
        this.messageAnyObject = messageAnyObject;
    }
}
/**
 * Represents a native JavaScript function virtually controlled by TypeScript
 * 
 * Through this class, a JavaScript function will be 
 * dynamically placed in the DOM of the page, 
 * executed and then destroyed. 
 * 
 * From this, it is possible to invoke functions from 
 * native JavaScript libraries from the written TypeScrit 
 * code.
 */
export class VirtualFunction
{
    public functionName: string;
    public functionArgs: string[];
    public functionBodyContent: string;
    private keep: boolean;
    public functionId: string;

    public toString(): string
    {
        return `function ${this.functionName}(${this.argNamesStr()});`;
    }

    /**
     * Defines a JavaScript virtual function
     * @param fnName the function name
     * @param fnArgNames An array with the names of the function's arguments (the variables that the function takes)
     * @param fnContent The literal body of the function; NOTE: you must not specify `{ or } ` here. Only the raw body of the function is allowed
     * @param keepAfterCalled Determines whether the function should remain active on the page after the first call. By default it is false.
     */
    constructor({ fnName, fnArgNames = [], fnContent, keepAfterCalled = false }:
        {
            fnName: string,
            fnArgNames?: string[],
            fnContent?: string,
            keepAfterCalled?: boolean,
        })
    {
        this.functionName = fnName;
        this.keep = keepAfterCalled;
        this.functionArgs = fnArgNames;
        this.functionBodyContent = fnContent;
        this.functionId = Widget.generateUUID();
    }

    /**
     * @param fnContent The literal body of the function; NOTE: you must not specify `{ or } ` here. Only the raw body of the function is allowed
     */
    setContent(fnContent: string): VirtualFunction
    {
        this.functionBodyContent = fnContent;
        return this;
    }

    /**
     * Calls the JavaScript function. 
     * Here the function will materialize in the 
     * DOM as a `<script> function here </script>` tag and the 
     * function will be inside it
     * @param argValues An array with the VALUES of the arguments defined in the function. Note that you must pass the array according to the actual parameters of the function.
     */
    call(...argValues: string[]) : void
    {
        var argNamesStr = this.argNamesStr();
        var argValuesStr = this.argValuesStr(...argValues);

        var fnString = `function ${this.functionName}(${argNamesStr}) {
            ${this.functionBodyContent}
        }
        
        ${this.functionName}(${argValuesStr});`;

        var fn = document.createElement('script');
        fn.id = this.functionId;
        fn.textContent = fnString;

        var els = document.getElementsByTagName('body');
        els[0].append(fn);

        if(this.keep == false)
          fn.remove();
    }

    private argValuesStr(...argValues: string[]) : string
    {
        var argValuesStr = '';
        for (var a = 0; a < argValues.length; a++)
            argValuesStr += `'${argValues[a]}', `;
        if (argValuesStr.endsWith(', '))
            argValuesStr = argValuesStr.substring(0, argValuesStr.length - 2);
        return argValuesStr;
    }

    private argNamesStr(): string
    {
        var argNamesStr = '';
        for (var a = 0; a < this.functionArgs.length; a++)
            argNamesStr += `${this.functionArgs[a]}, `;
        if (argNamesStr.endsWith(', '))
            argNamesStr = argNamesStr.substring(0, argNamesStr.length - 2);
        return argNamesStr;
    }
}
/**
 * A class that generates a simplified, 
 * standard Exception view at the point on 
 * the page where an error occurred
 */
export class DefaultExceptionPage
{
    constructor(error: Error)
    {
        if(UIPage.DISABLE_EXCEPTION_PAGE)
            return;
            
        var errorsStr = `${error.stack}`.split('\n');
        var title = `${error}`;
        var paneId = Widget.generateUUID();
        var rawHtml = `<div id="exceptionPane_${paneId}">`;
        rawHtml += `<img style="padding-left:30px; padding-top: 80px" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAHYAAAB2AH6XKZyAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAABFZJREFUeJztm0GLFEcUx/+vpzurQhaVCKJB/QSehJwjgrCzB4egm4PsIcJOEslNkNw8GQQ9Rp0h5GhcJQ4kuKeQfAEvCehRHNwNaxDUJbqZme56Ocz2Tk93VXXPdndZ7PaD3enueq/q/V6/elU9vQtUUkkllVSyc4VUDVfX/FlitFjgEBgIf1hEjll2zGM6Sj0xfh08/FDZAZvnK4KpefUT92ERAXBUDZbCA4zDDvPtIuC1AbAUPmz/uPQAWAy/2WYkAFbCmwrAdocH9DXAWng2OgVshDc2BWyFNxEAq+HfzxSwB95YDbAW3uwU2L7wQOoUsBTezBSwF95IDbAa3kwGyJ20At5kALYzPLCVnaAN8CYywGb4IpMg+xSwCd5EBuwEeCDLFLAR3lQGbHd4AHCVLebg/2OgVRN8p+d7j6+fprfFIupFGQBD8MsUiPp3p6b+Kh4tm6gzwMCdF8yz194jPJBlGYwcFznnGWhdO/nBnyUwTSTaDCiz4NUE34kO9+1v/iwLbjE23khhpJsshKxpi10XtAKm5vXP5O8S1ctgifBgwHO8J2PjlQE//HUYpH6XOPHTYBHwzMCVT+nf2HDFw4fXwMp3iRM9DRYFP3IsNp4KJOx4S/B6yfw0GPpQCLzKuYiuAH4PhHuMAvcohFhKh+elAP4RDoJjzPhD2q9Esu0DDMMzACHcL27UqQsAC4/4zL5Vf5GZG3J46rx54c21mzQAgEu/rF+AX3uaBg9kqQFlwGuCEAK6YqTVPkGDVwfdOQZ15PDuJjwAuMFGa4ZpoA+ADi4HvNSvWGoz9W8tPGIvbG6foMGbv905cDQISfiFFns+nO/z14Ay4SXOjac2A6CZvav9zjdLPBXqtJs0eNZzzxJwlwU9kMFPH/AXIWgm2fmEATD+PB+FH93h+q7A/2mhNcqE++coeL3qza/9434uhWduZIUHit4HQK6vrNyJMVliw429h5KZUAQ8UOQ+AHL9fPAbp4Lquwf9n6NBCCUPPFDUPkChr4SXOZdiI4TT6z2HiJu92gcB5p60r/A0dw2In+eEV/qjsGFBD+JzPpT75yjoBt55AHfHxolyaCTfPgDYGrwiA+Q21JEVvHhhXHvpzUNQZ6zL3DUAhuAht9EtddMfJQtjl92zoGEmZIEHtroPAPLBy7yL2RDzQ/1SR/Wp9eQSufbSm2fmzH9HPPk+AMgPr7o7ERsfwVfpSx03pvf7i9EgtJs0gCMuSvuVyGT7AMAIfFxFu9RRMgjSfhWS+qVoKfCaIIQ2DtwfL99bv+DXQOT0b2q3t8SND/f3O5fvrX/t10AIaj+ANONERP+dYEnwUr+iNkOFU4Fb6xKAxOof62BYUqjuU60LAWSFB7LUgNC5IuFVNZAlbSnn0mqf1kdEdDVgJTQuA/7Kr7xnbDxBKyXCP5doAtD+xwg1wVgu5c4z8I4Hx8cdpSZAyykgo9PM8LTMcL6UaFdSSSWVVLLj5X+IDiuFkg1oQQAAAABJRU5ErkJggg==" />`;
        rawHtml += `<h4 style="padding-left:30px"> ${title} </h4>`;
        rawHtml += `<p style="padding-left:30px; font-size: 20px">`;
        for (var i = 0; i < errorsStr.length; i++)
        {
            var erro = errorsStr[i];
            var msg = erro.trim();

            if (msg.indexOf('at') == 0)
            {
                var codePath = msg.substring(3, msg.indexOf('('));
                codePath = codePath.trim();
                msg = msg.replace(codePath,
                    `<span class="badge badge-secondary"> ${codePath} </span>`);
            }

            rawHtml += `${msg} <br/>`;
        }

        rawHtml += `</p>
            <button type="button" onclick="document.getElementById('exceptionPane_${paneId}').remove()" style="margin-left:30px; margin-bottom: 30px" class="btn btn-warning"> Hide </button>
        </div>
        `;
        
        var c = new DOMParser().parseFromString(rawHtml, 'text/html').body;
        document.body.prepend(c);
    }
}
export class UIHeadBinder extends WidgetBinder
{
    private head: UIHead;
    constructor(head: UIHead)
    {
        super(head);
        this.head = head;
    }

    getWidgetValue()
    {
        return this.head.value();
    }
    refreshUI(): void
    {
        var propValue = this.getModelPropertyValue();
        this.head.setText(`${propValue}`);
    }
    fillPropertyModel(): void { }
}

export class UIHead extends Widget implements IBindable
{
    private headType: string;
    private textContent: string;
    private headElement: HTMLHeadElement;
    constructor({ name, headType, text }:
        {
            name: string,
            headType: string,
            text: string
        })
    {
        super(name);

        if (headType == '' || headType == null || headType == undefined)
            headType = 'H1';

        this.textContent = text;
        this.headType = headType
            .replace('<', '')
            .replace('/', '')
            .replace('>', '');
    }
    getBinder(): WidgetBinder
    {
        return new UIHeadBinder(this);
    }
    protected htmlTemplate(): string
    {
        return `<${this.headType} id="fsHead"> </${this.headType}>`
    }
    protected onWidgetDidLoad(): void
    {
        this.headElement = this.elementById('fsHead');
        this.headElement.textContent = this.textContent;
    }

    public setCustomPresenter(presenter: ICustomWidgetPresenter<Widget>): void
    {
        presenter.render(this);
    }

    public setText(text: string): void
    {
        this.headElement.textContent = text;
    }

    public value(): string
    {
        return this.headElement.textContent;
    }
    public setEnabled(enabled: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    public addCSSClass(className: string): void
    {
        this.headElement.classList.add(className);
    }
    public removeCSSClass(className: string): void
    {
        this.headElement.classList.remove(className);
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        this.headElement.style.setProperty(propertyName, propertyValue);
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        this.headElement.style.position = position;
        this.headElement.style.left = marginLeft;
        this.headElement.style.top = marginTop;
        this.headElement.style.right = `${marginRight}`;
        this.headElement.style.bottom = `${marginBottom}`;
        this.headElement.style.transform = `${transform}`;
    }
    public setVisible(visible: boolean): void
    {
        this.headElement.hidden = (visible == false);
    }

}
export class ModalAction
{
    public text: string;
    public classes: string[];
    public onClick?: Function;
    public dismis: boolean;

    constructor(buttonText: string, dataDismiss: boolean, buttonClick?: Function, ...buttonClasses: string[])
    {
        this.text = buttonText;
        this.classes = buttonClasses;
        this.onClick = buttonClick;
        this.dismis = dataDismiss;

        if (this.text == null)
            this.text = 'Modal action';
        if (this.classes == null || this.classes.length == 0)
            this.classes = ['btn', 'btn-primary'];
    }

    public setButton(button: HTMLButtonElement, modal: UIDialog)
    {
        var self = this;
        if (Misc.isNull(this.onClick) == false)
            button.onclick = function ()
            {
                self.onClick(modal);
            };
    }
}
export class RadioOption
{
    public optionContainer: HTMLDivElement;
    public radioInput: HTMLInputElement;
    public radioLabel: HTMLLabelElement;

    constructor(text: string,
        value: string, fieldSetId: string, shell: PageShell)
    {
        var template: UITemplateView = new UITemplateView(
            `<div id="radioOptionContainer" style="margin-right: 10px" class="custom-control custom-radio">
    <input id="radioInput" type="radio" name="fieldset" class="custom-control-input">
    <label id="radioLabel" class="custom-control-label font-weight-normal" for=""> Radio Option </label>
</div>
`,
            shell);

        this.optionContainer = template.elementById('radioOptionContainer');
        this.radioInput = template.elementById('radioInput');
        this.radioLabel = template.elementById('radioLabel');

        this.radioLabel.textContent = text;
        this.radioInput.value = value;
        this.radioInput.name = fieldSetId;
        this.radioLabel.htmlFor = this.radioInput.id;
    }

    isChecked(): boolean
    {
        return this.radioInput.checked;
    }

    value(): string
    {
        return this.radioInput.value;
    }

    setChecked(isChecked: boolean): void
    {
        this.radioInput.checked = isChecked;
    }

    setEnabled(isEnabled: boolean): void
    {
        this.radioInput.disabled = (isEnabled == false);
    }
}

export class UIRadioGroupBinder extends WidgetBinder
{
    private radioGp: UIRadioGroup;
    constructor(radioGroup: UIRadioGroup)
    {
        super(radioGroup);
        this.radioGp = radioGroup;
    }

    getWidgetValue()
    {
        return this.radioGp.value();
    }
    refreshUI(): void
    {
        var value = this.getModelPropertyValue();
        this.radioGp.setValue(value);
    }
    fillPropertyModel(): void
    {
        var value = this.getWidgetValue();
        this.setModelPropertyValue(value);
    }

}

export class UIRadioGroup extends Widget implements IBindable
{
    public groupContainer: HTMLDivElement;
    public groupTitle: HTMLLabelElement;
    public fieldSet: HTMLFieldSetElement;


    private options: Array<RadioOption> = [];
    private title: string;
    private orientation: string;

    private initialOptions: Array<any> = [];

    /**
    * 
    * @param direction Flex direction: 'column' / 'row'
    * @param options array { t:'Option Text', v: 'option_value' }
    */
    constructor({ name, title = '', orientation = 'vertical', options = [] }:
        {
            name: string,
            title?: string,
            orientation?: string,
            options?: Array<any>
        })
    {
        super(name);

        this.title = title;
        this.orientation = orientation;
        this.initialOptions = options;
    }
    getBinder(): WidgetBinder
    {
        return new UIRadioGroupBinder(this);
    }

    protected onWidgetDidLoad(): void
    {
        this.groupContainer = this.elementById('fsRadioGroup');
        this.groupTitle = this.elementById('groupTitle');
        this.fieldSet = this.elementById('fieldSet');

        this.groupTitle.textContent = this.title;

        if (this.orientation != 'horizontal' && this.orientation != 'vertical')
            throw new Error(`Invalid value '${orientation}' for 'orientation' parmeter. Accepted values are 'vertical' or 'horizontal'`);

        if (this.orientation == 'vertical')
            this.fieldSet.classList.add(`flex-column`);
        if (this.orientation == 'horizontal')
            this.fieldSet.classList.add(`flex-row`);

        this.addOptions(this.initialOptions);
    }

    protected htmlTemplate(): string
    {
        return `
<div id="fsRadioGroup">
  <label id="groupTitle" class="font-weight-normal" style="margin-left: 3px"> </label>
  <fieldset class="d-flex" id="fieldSet">

  </fieldset>
</div>`;
    }

    /**
     * 
     * @param options  array { t:'Option Text', v: 'option_value' }
     */
    addOptions(options: Array<any>)
    {
        for (var i = 0; i < options.length; i++)
        {
            var op = options[i];
            this.addOption(op.t, op.v);
        }
    }

    addOption(text: string, value: string)
    {
        var newOpt: RadioOption = new RadioOption(
            text,
            value,
            this.fieldSet.id,
            this.getPageShell()
        );
        this.options.push(newOpt);
        this.fieldSet.appendChild(newOpt.optionContainer);
    }

    fromList(models: Array<any>, textKey: string, valueKey: string)
    {
        for (var i = 0; i < models.length; i++)
        {
            var model = models[i];
            var text = model[textKey];
            var value = model[valueKey];
            this.addOption(text, value);
        }
    }

    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        renderer.render(this);
    }

    public selectedOption(): RadioOption
    {
        for (var i = 0; i < this.options.length; i++)
            if (this.options[i].isChecked())
                return this.options[i];
    }

    public setValue(value: string): void
    {
        for (var i = 0; i < this.options.length; i++)
        {
            if (this.options[i].value() == value)
                this.options[i].setChecked(true);
            else
                this.options[i].setChecked(false);
        }
    }

    public value(): string
    {
        for (var i = 0; i < this.options.length; i++)
        {
            var op = this.options[i];
            if (op.isChecked())
                return op.value();
        }
        return '';
    }
    public setEnabled(enabled: boolean): void
    {
        for (var i = 0; i < this.options.length; i++)
        {
            var op = this.options[i];
            op.setEnabled(enabled);
        }
    }

    public addCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public removeCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        this.groupContainer.style.position = position;
        this.groupContainer.style.left = marginLeft;
        this.groupContainer.style.top = marginTop;
        this.groupContainer.style.right = marginRight;
        this.groupContainer.style.bottom = marginBottom;
        this.groupContainer.style.transform = transform;
    }
    public setVisible(visible: boolean): void
    {
        this.groupContainer.hidden = (visible == false);
    }

}
export class UIButton extends Widget
{
    public buttonElement: HTMLButtonElement;
    public imageElement: HTMLImageElement;

    private text: string;
    public onClick: Function;
    private btnClass: string;
    private imageSrc: string;
    private imageWidth: number;

    constructor({ name, text, imageSrc, imageWidth, btnClass = 'btn-light' }:
        {
            name: string;
            text: string;
            imageSrc?: string;
            imageWidth?: number,
            btnClass?: string
        })
    {
        super(name);

        this.imageSrc = imageSrc;
        this.imageWidth = imageWidth;
        this.text = text;
        this.btnClass = btnClass;
    }

    protected htmlTemplate(): string
    {
        if (this.imageSrc != '' && this.imageSrc != null && this.imageSrc != undefined)
        {
            return `
<button id="fsButton" type="button" style="height: 35px" class="btn btn-block"> 
     <img alt="img" id="fsButtonImage" src="/icons/sb_menu.png" width="20" ></img> 
</button>`
        }
        else
            return `<button id="fsButton" type="button" style="height: 35px" class="btn btn-block">Button</button>`
    }
    protected onWidgetDidLoad(): void
    {
        var self = this;
        this.buttonElement = this.elementById('fsButton');
        this.buttonElement.classList.add(this.btnClass);
        this.imageElement = this.elementById('fsButtonImage');

        this.setText(this.text);
        
        if (self.onClick != null)
        {
            this.buttonElement.onclick = function (ev)
            {
                self.onClick(ev);
            };
        }
    }

    public setText(text: string)
    {
        this.buttonElement.innerText = text;

        if (this.imageSrc != '' && this.imageSrc != null && this.imageSrc != undefined)
        {
            this.imageElement.src = this.imageSrc;
            this.imageElement.width = this.imageWidth;
            this.buttonElement.appendChild(this.imageElement);
        }
    }

    public value(): string
    {
        throw new Error("Button does not support value");
    }

    public setVisible(visible: boolean): void
    {
        this.buttonElement.hidden = (visible == false);
    }

    public setEnabled(enabled: boolean): void
    {
        this.buttonElement.disabled = (enabled == false);
    }

    public addCSSClass(className: string): void
    {
        this.buttonElement.classList.add(className);
    }

    public removeCSSClass(className: string): void
    {
        this.buttonElement.classList.remove(className);
    }

    public applyCSS(propertyName: string, propertyValue: string): void
    {
        this.buttonElement.style.setProperty(propertyName, propertyValue);
    }

    public setPosition(position: string,
        marginLeft: string,
        marginTop: string,
        marginRight?: string,
        marginBottom?: string,
        transform?: string): void
    {
        this.buttonElement.style.position = position;
        this.buttonElement.style.left = marginLeft;
        this.buttonElement.style.top = marginTop;
        this.buttonElement.style.right = `${marginRight}`;
        this.buttonElement.style.bottom = `${marginBottom}`;
        this.buttonElement.style.transform = `${transform}`;
    }

    public setCustomPresenter(renderer: ICustomWidgetPresenter<UIButton>): void
    {
        renderer.render(this);
    }
}
export class UICheckBoxBinder extends WidgetBinder
{
    private checkBox: UICheckBox;
    constructor(checkBox: UICheckBox)
    {
        super(checkBox);
        this.checkBox = checkBox;
    }

    refreshUI(): void
    {
        var value = this.getModelPropertyValue();
        this.checkBox.setChecked(value);
    }
    fillPropertyModel(): void
    {
        var checked: boolean = this.checkBox.isChecked();
        this.setModelPropertyValue(checked);
    }
    getWidgetValue()
    {
        var checked: boolean = this.checkBox.isChecked();
        return checked;
    }
}

export class UICheckBox extends Widget implements IBindable
{
    public divContainer: HTMLDivElement;
    public checkElement: HTMLInputElement;
    public checkLabel: HTMLLabelElement;
    public onCheckedChange: Function;


    private labelText: string;
    constructor({name, text }:
        { name: string; text: string; })
    {
        super(name);

        this.labelText = text;
    }
    getBinder(): WidgetBinder
    {
        return new UICheckBoxBinder(this);
    }

    protected htmlTemplate(): string
    {
        return `
<div id="fsCheckBox" class="custom-control custom-checkbox">
  <input id="checkElement" class="custom-control-input" type="checkbox" value="">
  <label id="checkLabel" class="custom-control-label font-weight-normal" for="checkElement">
    Default checkbox
  </label>
</div>`
    }

    protected onWidgetDidLoad(): void
    {
        var self = this;
        self.divContainer = self.elementById('fsCheckBox');
        self.checkElement = self.elementById('checkElement');
        self.checkLabel = self.elementById('checkLabel');
        self.checkLabel.htmlFor = self.checkElement.id;
        self.checkLabel.textContent = self.labelText;

        self.checkElement.onchange = function(ev)
        {
            if(self.onCheckedChange != null) self.onCheckedChange({checked: self.checkElement.checked, event: ev});
        };
    }

    public setText(text:string): void
    {
        this.labelText = text;
        this.checkLabel.textContent = this.labelText;
    }

    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        renderer.render(this);
    }
    public value(): string
    {
        return this.checkElement.checked.toString();
    }
    public setEnabled(enabled: boolean): void
    {
        this.checkElement.disabled = (enabled == false);
    }
    public addCSSClass(className: string): void
    {
        this.checkElement.classList.add(className);
    }
    public removeCSSClass(className: string): void
    {
        this.checkElement.classList.remove(className);
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        this.checkElement.style.setProperty(propertyName, propertyValue);
    }
    public setPosition(position: string, 
        marginLeft: string,
        marginTop: string, 
        marginRight: string, 
        marginBottom: string, 
        transform?: string): void
    {
        this.divContainer.style.position = position;
        this.divContainer.style.left = marginLeft;
        this.divContainer.style.top = marginTop;
        this.divContainer.style.right = marginRight;
        this.divContainer.style.bottom = marginBottom;
        this.divContainer.style.transform = `${transform}`;
    }

    public setVisible(visible: boolean): void
    {
       this.divContainer.hidden = (visible == false);
    }
    
    public setChecked(isChecked: boolean): void
    {
        this.checkElement.checked = isChecked;
    }
    public isChecked(): boolean
    {
        return this.checkElement.checked;
    }
}
export class UIImageBinder extends WidgetBinder
{
    private img: UIImage;
    constructor(image: UIImage)
    {
        super(image);
        this.img = image;
    }
    getWidgetValue()
    {
       return this.img.value();
    }
    refreshUI(): void
    {
       var valueModel = this.getModelPropertyValue();
       this.img.setSource(valueModel);
    }
    fillPropertyModel(): void { }
}

export class UIImage extends Widget implements IBindable
{
    public image: HTMLImageElement;
    
    private imgSrc:string;
    private imgAlt:string;
    private imgCssClass: string;

    constructor({name, src, cssClass, alt}: 
        {
          name: string, 
          src?: string, 
          cssClass?:string, 
          alt?: string
        })
    {
        super(name);

        if(cssClass == null)
           cssClass = 'img-fluid'
        
        this.imgCssClass = cssClass;
        this.imgSrc = src;
        this.imgAlt = `${alt}`;
    }
    getBinder(): WidgetBinder
    {
        return new UIImageBinder(this);
    }

    protected htmlTemplate(): string
    {
        return `<img id="fsImageView" src="" class="img-fluid" alt="">`;
    }

    protected onWidgetDidLoad(): void
    {
        this.image = this.elementById('fsImageView');
        this.image.alt = this.imgAlt;
        this.setSource(this.imgSrc);
        this.addCSSClass(this.imgCssClass);
    }

    public setSource(imgSource: string)
    {
        this.imgSrc = imgSource;
        this.image.src = this.imgSrc;
    }

    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        renderer.render(this);
    }
    public value(): string
    {
        return this.imgSrc;
    }
    public setEnabled(enabled: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    public addCSSClass(className: string): void
    {
        this.image.classList.add(className);
    }
    public removeCSSClass(className: string): void
    {
        this.image.classList.remove(className);
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        this.image.style.setProperty(propertyName, propertyValue);
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        this.image.style.position = position;
        this.image.style.left = marginLeft;
        this.image.style.top = marginTop;
        this.image.style.right = marginRight;
        this.image.style.bottom = marginBottom;
        this.image.style.transform = `${transform}`;
    }
    public setVisible(visible: boolean): void
    {
        this.image.hidden = (visible == false);
    }
}
export class UILabelBinder extends WidgetBinder
{
    private label: UILabel;
    constructor(label: UILabel)
    {
        super(label);
        this.label = label;
    }

    refreshUI(): void
    {
        var value = this.getModelPropertyValue();
        this.label.setText(`${value}`);
    }
    fillPropertyModel(): void
    {
        var text: string = this.label.getText();
        this.setModelPropertyValue(text);
    }
    getWidgetValue()
    {
        var text: string = this.label.getText();
        return text;
    }
}

export class UILabel extends Widget implements IBindable
{
    public label: HTMLLabelElement;
    private lblText: string;
    constructor({name, text}:
        {name: string, text: string})
    {
        super(name);
        this.lblText = text;
    }
    getBinder(): WidgetBinder
    {
        return new UILabelBinder(this);
    }
    protected htmlTemplate(): string
    {
        return `<label id="fsLabel" class="label"> Default label </label>`;
    }

    protected onWidgetDidLoad(): void
    {
        this.label = this.elementById('fsLabel');
        this.label.textContent = this.lblText;
    }

    public getText(): string
    {
        return this.value();
    }

    public setText(text: string): void
    {
        this.label.textContent = text;
    }

    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        renderer.render(this);
    }
    public value(): string
    {
        return `${this.label.textContent}`;
    }

    public setEnabled(enabled: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    public addCSSClass(className: string): void
    {
        this.label.classList.add(className);
    }
    public removeCSSClass(className: string): void
    {
        this.label.classList.add(className);
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        this.label.style.setProperty(propertyName, propertyValue);
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        this.label.style.position = position;
        this.label.style.left = marginLeft;
        this.label.style.top = marginTop;
        this.label.style.right = marginRight;
        this.label.style.bottom = marginBottom;
        this.label.style.transform = `${transform}`;
    }
    public setVisible(visible: boolean): void
    {
        this.label.hidden = (visible == false);
    }
}
export class UIListBinder extends WidgetBinder
{
    private listView: UIList;

    constructor(listView: UIList)
    {
        super(listView);
        this.listView = listView;
    }
    refreshUI(): void
    {
        var viewModels: Array<any> = this.getModelPropertyValue();
        this.listView.fromList(viewModels, this.valueProperty, this.displayProperty);
    }
    getWidgetValue()
    {
        var item = this.listView.selectedItem();
        if (item == null) return null;
        return item.value;
    }
    fillPropertyModel(): void { }
}

export class UIList extends Widget implements IBindable
{
    protected htmlTemplate(): string
    {
        return `
<div id="fsListView" class="list-group">
</div>`
    }
    public items: Array<IListItemTemplate> = [];
    public divContainer: HTMLDivElement;

    private itemClickedCallback: Function;

    private templateProvider: IListItemTemplateProvider;

    public customBehaviorColors = false;
    public unSelectedBackColor: string = null;
    public unSelectedForeColor: string = null;
    public selectedBackColor: string = null;
    public selectedForeColor: string = null;


    /**
     * 
     * @param itemClicked Function to handle onClick item event. 
     * 
     * Parameters: **(item: IListItemTemplate, ev: Event)**
     */
    constructor({ name, itemClicked = null, templateProvider = null }:
        {
            name: string;
            itemClicked?: Function,
            templateProvider?: IListItemTemplateProvider
        })
    {
        super(name);

        this.templateProvider = templateProvider;
        this.itemClickedCallback = itemClicked;
    }

    public setTemplateProvider(itemTemplateProvider: IListItemTemplateProvider)
    {
        this.templateProvider = itemTemplateProvider;
    }

    /**
     * Changes the color selection behavior for each UIList item. 
     * 
     * NOTE: not every implementation of 'IListItemTemplate'
     * will be able to obey this
     */
    public changeColors(selectedBack: string, selectedFore: string,
        unSelectedBack: string, unSelectedFore: string)
    {
        this.customBehaviorColors = true;
        this.selectedBackColor = selectedBack;
        this.selectedForeColor = selectedFore;
        this.unSelectedBackColor = unSelectedBack;
        this.unSelectedForeColor = unSelectedFore;
    }

    public itemTemplateProvider(): IListItemTemplateProvider
    {
        return this.templateProvider;
    }

    getBinder(): WidgetBinder
    {
        return new UIListBinder(this);
    }

    public fromList(viewModels: Array<any>, valueProperty?: string, displayProperty?: string): void
    {
        if (viewModels == null || viewModels == undefined || viewModels.length == 0) 
        {
            try
            {
                var templateProvider = this.itemTemplateProvider();
                if (templateProvider != null)
                {
                    var customItem = templateProvider.getListItemTemplate(this, null);
                    if (customItem != null && customItem != undefined)
                        this.addItem(customItem);
                }
            } catch (err: any | object | Error)
            {
                console.error(err);
            }
            return;
        };
        this.divContainer.innerHTML = '';
        for (var i = 0; i < viewModels.length; i++)
        {
            var viewModel: any | object = viewModels[i];
            var text = (displayProperty == null ? `${viewModel}` : viewModel[displayProperty]);
            var value = (valueProperty == null ? `${viewModel}` : viewModel[valueProperty]);

            if (this.itemTemplateProvider() == null)
            {
                var defaultItemTemplate = new ListItem(
                    `${i + 1}`,
                    text,
                    value);

                this.addItem(defaultItemTemplate);
            }
            else
            {
                var templateProvider = this.itemTemplateProvider();
                var customItem = templateProvider.getListItemTemplate(this, viewModel);
                this.addItem(customItem);
            }
        }
    }

    protected onWidgetDidLoad(): void
    {
        this.divContainer = this.elementById('fsListView');
    }

    public onItemClicked(item: IListItemTemplate, ev: Event): void
    {
        for (var i = 0; i < this.items.length; i++)
            this.items[i].unSelect();
        item.select();
        if (this.itemClickedCallback != null && this.itemClickedCallback != undefined)
            this.itemClickedCallback(item, ev);
    }

    public addItem(item: IListItemTemplate): UIList
    {
        item.setOwnerList(this);
        this.items.push(item);
        var view: HTMLAnchorElement = item.itemTemplate();
        this.divContainer.append(view);
        return this;
    }

    public removeItem(item: IListItemTemplate): void
    {
        for (var i = 0; i < this.divContainer.children.length; i++)
        {
            var view: HTMLAnchorElement = this.divContainer.children[i] as HTMLAnchorElement;
            if (view.id == item.itemName)
            {
                var indx = this.items.indexOf(item);
                if (indx >= 0) this.items.splice(indx, 1);

                this.divContainer.removeChild(view);
                item = null;
                return;
            }
        }
    }

    public setSelectedValue(itemValue: any): void
    {
        for (var i = 0; i < this.items.length; i++)
        {
            var item = this.items[i];
            if (item.value == itemValue)
                item.select();
            else
                item.unSelect();
        }
    }

    public setSelectedItem(selectedItem: IListItemTemplate): void
    {
        for (var i = 0; i < this.items.length; i++)
        {
            var item = this.items[i];
            item.unSelect();
        }
        selectedItem.select();
    }

    public selectedItem(): IListItemTemplate
    {
        for (var i = 0; i < this.items.length; i++)
        {
            var item = this.items[i];
            if (item.isSelected())
                return item;
        }
        return null;
    }
    public selectedValue(): any | object
    {
        var sItem = this.selectedItem();
        if (sItem == null || sItem == undefined) return null;
        return sItem.value;
    }
    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        renderer.render(this);
    }
    public value(): string
    {
        return this.selectedValue();
    }
    public setEnabled(enabled: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    public addCSSClass(className: string): void
    {
        this.divContainer.classList.add(className);
    }
    public removeCSSClass(className: string): void
    {
        this.divContainer.classList.remove(className);
    }

    public applyCSS(propertyName: string, propertyValue: string): void
    {
        this.divContainer.style.setProperty(propertyName, propertyValue);
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        this.divContainer.style.position = position;
        this.divContainer.style.left = marginLeft;
        this.divContainer.style.top = marginTop;
        this.divContainer.style.right = marginRight;
        this.divContainer.style.bottom = marginBottom;
        this.divContainer.style.transform = transform;
    }
    public setVisible(visible: boolean): void
    {
        this.divContainer.hidden = (visible == false);
    }
}
export class UIDialog extends Widget implements INotifiable
{
    public static $: UIDialog;

    private showFunction: VirtualFunction;

    public contentTemplate: UITemplateView;
    private modalActions: ModalAction[] = [];
    private titleText: string;

    public modalContainer: HTMLDivElement;
    public titleElement: HTMLHeadElement;
    public bodyContainer: HTMLDivElement;
    public footerContainer: HTMLDivElement;

    private shell: PageShell;

    private modalContext: WidgetContext;

    constructor({ shell, name, title, contentTemplate, actions }:
        {
            shell: PageShell,
            name: string;
            title: string;
            contentTemplate: UITemplateView;
            actions: ModalAction[];
        })
    {
        super(name);

        this.shell = shell;
        this.titleText = title;
        this.contentTemplate = contentTemplate;
        this.modalActions = actions;

        var body: Element = shell.getPageBody();
        var modalDivContainer: Element = shell.elementById('modalContainer');
        if (modalDivContainer == null)
        {
            modalDivContainer = shell.createElement('div');
            modalDivContainer.id = 'modalContainer';
            body.appendChild(modalDivContainer);
        }

        this.modalContext = new WidgetContext(
            shell,
            [modalDivContainer.id],
            null);

    }

    protected htmlTemplate(): string
    {
        return `
 <div id="fsModalView" class="modal fade" role="dialog">
    <div class="modal-dialog" role="document">        
        <div class="modal-content">
            <div class="modal-header">
                <h5 id="modalTitle" class="modal-title" id="exampleModalLongTitle">Modal title</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
                </button>
            </div>
            
            <div id="modalBody" class="modal-body">
                
            </div>

            <div id="modalFooter" class="modal-footer">
        
            </div>
        </div>
    </div>
  </div>`;

    }

    protected onWidgetDidLoad(): void
    {
        var self = this;
        self.titleElement = self.elementById('modalTitle');
        self.bodyContainer = self.elementById('modalBody');
        self.footerContainer = self.elementById('modalFooter');
        self.titleElement.textContent = self.titleText;
        self.modalContainer = self.elementById('fsModalView');
        self.bodyContainer.appendChild(self.contentTemplate.content());


        for (var i = 0; i < self.modalActions.length; i++)
        {
            const action: ModalAction = self.modalActions[i];
            const btn: HTMLButtonElement = self.shell.createElement('button');
            btn.type = 'button';
            btn.id = `modalAction_${Widget.generateUUID()}`;
            btn.textContent = action.text;

            for (var c = 0; c < action.classes.length; c++)
                btn.classList.add(action.classes[c]);

            action.setButton(btn, this);
            if (action.dismis)
                btn.setAttribute('data-dismiss', 'modal');

            self.footerContainer.appendChild(btn);
        }

        self.showFunction = new VirtualFunction({
            fnName: 'modalShow',
            fnArgNames: [],
            keepAfterCalled: true
        })

        self.showFunction.setContent(`
            var md = new bootstrap.Modal(document.getElementById('${self.modalContainer.id}'), { backdrop: false })
            md.show();
            $('#${self.modalContainer.id}').on('hidden.bs.modal', function (e) {
                document.getElementById('${self.modalContainer.id}').remove();
                document.getElementById('${self.showFunction.functionId}').remove();
            })`);


        self.showFunction.call();
    }

    public show(): void
    {
        this.modalContext.addWidget('modalContainer', this);
        this.modalContext.build(this, false);
        UIDialog.$ = this;
    }

    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        renderer.render(this);
    }
    public value(): string
    {
        throw new Error("Method not implemented.");
    }
    public setEnabled(enabled: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    public addCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public removeCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setVisible(visible: boolean): void
    {
        throw new Error("Method not implemented.");
    }

}
export class UINavBar extends Widget
{

    public navBar: HTMLDivElement;
    public leftLinks: HTMLUListElement;
    public rightLinks: HTMLUListElement;
    public brandText: HTMLAnchorElement;
    public pushMenuButton: HTMLAnchorElement;

    constructor(name: string)
    {
        super(name);
    }

    protected htmlTemplate(): string
    {
        return `
<nav id="fsNavbar" class="navbar fixed-top">
  
    <!-- Left navbar links -->
    <ul id="navLeftLinks" class="navbar-nav">
        <li class="nav-item">
           <a id="btnPushMenu" class="nav-link" data-widget="pushmenu" href="#" role="button"><i class="fas fa-bars"></i></a>
        </li>
       
     
    </ul>

   <a id="brandText" class="navbar-brand">My First App</a>

    <!-- Right navbar links -->
    <ul id="navRightLinks" class="navbar-nav ml-auto">
    </ul>
</nav>`
    }

    onWidgetDidLoad(): void
    {
        this.navBar = this.elementById('fsNavbar');
        this.leftLinks = this.elementById('navLeftLinks')
        this.rightLinks = this.elementById('navRightLinks')
        this.brandText = this.elementById('brandText');
        this.pushMenuButton = this.elementById('btnPushMenu');

        this.pushMenuButton.style.marginLeft = '5px';
        this.brandText.style.marginLeft = '10px';
        this.navBar.style.boxShadow = '0 0 1em lightgray';
    }

    public setEnabled(enabled: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    public value(): string
    {
        throw new Error("Method not implemented.");
    }
    public addCSSClass(className: string): void
    {
        this.navBar.classList.add(className);
    }

    public removeCSSClass(className: string): void
    {
        this.navBar.classList.remove(className);
    }

    public applyCSS(propertyName: string, propertyValue: string): void
    {
        this.navBar.style.setProperty(propertyName, propertyValue);
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        this.navBar.style.position = position;
        this.navBar.style.left = marginLeft;
        this.navBar.style.top = marginTop;
        this.navBar.style.right = marginRight;
        this.navBar.style.bottom = marginBottom;
        this.navBar.style.transform = transform;
    }
    public setVisible(visible: boolean): void
    {
        this.navBar.hidden = (visible == false);
    }
    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        renderer.render(this);
    }


}
export class UIProgressBar extends Widget
{
    protected onWidgetDidLoad(): void
    {
        throw new Error("Method not implemented.");
    }
    protected htmlTemplate(): string
    {
        throw new Error("Method not implemented.");
    }
    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        throw new Error("Method not implemented.");
    }
    public value(): string
    {
        throw new Error("Method not implemented.");
    }
    public setEnabled(enabled: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    public addCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public removeCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setVisible(visible: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    
}
export class UISelectBinder extends WidgetBinder
{
    private select: UISelect;
    constructor(select: UISelect)
    {
        super(select);
        this.select = select;
    }
    getWidgetValue()
    {
        return this.select.value();
    }
    refreshUI(): void
    {
        var models: Array<any | object> = this.getModelPropertyValue();
        if (this.bindingHasPath)
            this.select.fromList(models, this.valueProperty, this.displayProperty);
        else
            this.select.fromList(models);
    }
    fillPropertyModel(): void { }
}

export class UISelect extends Widget implements IBindable
{
    protected htmlTemplate(): string
    {
        return `
<div id="fsSelect" class="form-group">
    <label id="selectTitle" style="margin: 0px; padding: 0px; font-weight:normal !important;" for="selectEl"> Select Title </label>
    <select style="height: 35px" id="selectEl" class="form-control">
    </select>
</div>`
    }

    private divContainer: HTMLDivElement = null;
    private title: HTMLLabelElement = null;
    private select: HTMLSelectElement = null;
    public onSelectionChanged: Function = null;
    private initialTitle: string = null;

    constructor({ name, title }:
        {
            name: string,
            title: string
        })
    {
        super(name);
        this.initialTitle = title;
    }
    getBinder(): WidgetBinder
    {
        return new UISelectBinder(this);;
    }

    protected onWidgetDidLoad(): void
    {
        var self = this;

        this.divContainer = this.elementById('fsSelect');
        this.title = this.elementById('selectTitle');
        this.select = this.elementById('selectEl');

        this.select.onchange = function (ev)
        {
            if (self.onSelectionChanged != null)
                self.onSelectionChanged(ev);
        };
        this.title.textContent = this.initialTitle;

    }
    public setSelectedOption(optionValue: any): void
    {
        try
        {
            for (var i = 0; i < this.select.options.length; i++)
                this.select.options[i].selected = false;

            for (var i = 0; i < this.select.options.length; i++)
            {
                var option = this.select.options[i];

                if (option.value == optionValue)
                {
                    option.selected = true;
                    return;
                }
            }
        } catch (error)
        {
            this.processError(error);
        }
    }

    public fromList(models: Array<any>,
        valueProperty?: string,
        displayProperty?: string): void
    {
        if (models == null || models == undefined) return;
        try
        {
            var optionsFromModels: Array<SelectOption> = [];
            for (var i = 0; i < models.length; i++)
            {
                var model = models[i];
                var option: SelectOption = null;

                if (valueProperty != null && valueProperty != undefined)
                    option = new SelectOption(model[valueProperty], model[displayProperty])
                else
                    option = new SelectOption(`${models[i]}`, `${models[i]}`);

                optionsFromModels.push(option);
            }
            this.addOptions(optionsFromModels);
        }
        catch (error)
        {
            this.processError(error);
        }
    }

    public addOptions(options: Array<SelectOption>): void
    {
        this.select.innerHTML = '';
        for (var i = 0; i < options.length; i++)
            this.addOption(options[i]);
    }

    public addOption(option: SelectOption): UISelect
    {
        try
        {
            var optionEL: HTMLOptionElement = document.createElement('option');
            optionEL.value = option.value;
            optionEL.textContent = option.text;
            this.select.add(optionEL);
            return this;
        }
        catch (error)
        {
            this.processError(error);
        }
    }

    public setTitle(title: string): void
    {
        this.title.textContent = title;
    }

    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        try
        {
            renderer.render(this);
        }
        catch (error)
        {
            this.processError(error);
        }
    }

    public value(): string
    {
        return this.select.value;
    }
    public addCSSClass(className: string): void
    {
        this.select.classList.add(className);
    }

    public removeCSSClass(className: string): void
    {
        this.select.classList.remove(className);
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        this.select.style.setProperty(propertyName, propertyValue);
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        this.divContainer.style.position = position;
        this.divContainer.style.left = marginLeft;
        this.divContainer.style.top = marginTop;
        this.divContainer.style.right = marginRight;
        this.divContainer.style.bottom = marginBottom;
        this.divContainer.style.transform = transform;
    }
    public setVisible(visible: boolean): void
    {
        this.divContainer.hidden = (visible == false);
    }

    public setEnabled(enabled: boolean): void
    {
        this.select.disabled = (enabled == false);
    }
}
export class UISpinner extends Widget
{
    private colorCls: string;
    private initialVisible: boolean;

    public containerDiv: HTMLDivElement = null;
    public spanSpinner: HTMLSpanElement = null;

    constructor({ name, colorClass, visible = true }:
        {
            name: string,
            colorClass: string,
            visible: boolean
        })
    {
        super(name);
        this.colorCls = colorClass;
        this.initialVisible = visible;
    }

    protected onWidgetDidLoad(): void
    {
        this.containerDiv = this.elementById('container');
        this.spanSpinner = this.elementById('spnSpinner');

        this.setVisible(this.initialVisible);
    }
    protected htmlTemplate(): string
    {
        var colorClass = this.colorCls;
        if (colorClass == 'primary') colorClass = 'text-primary';
        if (colorClass == '') colorClass = 'text-primary';

        return `
<div id="container" class="spinner-border ${colorClass}" role="status">
    <span id="spnSpinner" class="sr-only"/>
</div>
        `
    }
    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        renderer.render(this);
    }
    public value(): string
    {
        return null;
    }
    public setEnabled(enabled: boolean): void
    {

    }
    public addCSSClass(className: string): void
    {

    }
    public removeCSSClass(className: string): void
    {

    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        
    }
    public setVisible(visible: boolean): void
    {
        this.containerDiv.hidden = (visible == false);
    }

}
export class UISwitcher extends Widget
{
    protected onWidgetDidLoad(): void
    {
        throw new Error("Method not implemented.");
    }
    protected htmlTemplate(): string
    {
        throw new Error("Method not implemented.");
    }
    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        throw new Error("Method not implemented.");
    }
    public value(): string
    {
        throw new Error("Method not implemented.");
    }
    public setEnabled(enabled: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    public addCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public removeCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setVisible(visible: boolean): void
    {
        throw new Error("Method not implemented.");
    }

}
export class Mask
{
    /** 00/00/0000 */
    public static DATE: string = '00/00/0000';

    /**00:00:00 */
    public static TIME: string = '00:00:00';

    /**00/00/0000 00:00:00 */
    public static DATE_TIME: string = '00/00/0000 00:00:00';

    /**00000-000 */
    public static CEP: string = '00000-000';

    /**0000-0000 */
    public static PHONE: string = '0000-0000';

    /** (00) 0000-0000*/
    public static PHONE_DDD: string = '(00) 0000-0000';

    /**(000) 000-0000 */
    public static PHONE_US: string = '(000) 000-0000';

    /**000.000.000-00 */
    public static CPF: string = '000.000.000-00';

    /**00.000.000/0000-00 */
    public static CNPJ: string = '00.000.000/0000-00';

    /**000.000.000.000.000,00 */
    public static MONEY: string = '000.000.000.000.000,00';

    /**#.##0,00 */
    public static MONEY2: string = '#.##0,00';

    /**099.099.099.099 */
    public static IP_ADDRESS: string = '099.099.099.099';

    /**##0,00% */
    public static PERCENT: string = '##0,00%';

    public static array(): Array<string>
    {
        return [
            this.DATE,
            this.TIME,
            this.DATE_TIME,
            this.CEP,
            this.PHONE,
            this.PHONE_DDD,
            this.PHONE_US,
            this.CPF,
            this.CNPJ,
            this.MONEY,
            this.MONEY2,
            this.IP_ADDRESS,
            this.PERCENT
        ];
    }
}

export class UITextBoxBinder extends WidgetBinder
{
    private textBox: UITextBox;
    constructor(textBox: UITextBox) 
    {
        super(textBox);
        this.textBox = this.widget as UITextBox;
    }
    refreshUI(): void
    {
        var value = this.getModelPropertyValue();
        this.textBox.setText(`${value}`);
    }
    fillPropertyModel(): void
    {
        var text: string = this.textBox.getText();
        this.setModelPropertyValue(text);
    }
    getWidgetValue()
    {
        var text: string = this.textBox.getText();
        return text;
    }
}

export class UITextBox extends Widget implements IBindable
{
    protected htmlTemplate(): string
    {
        return `
<div id="textEntry" class="form-group">
    <label id="entryTitle" style="margin: 0px; padding: 0px; font-weight:normal !important;" for="inputEntry"> Entry Title </label>
    <input id="entryInput" class="form-control form-control-sm"  placeholder="Entry placeholder">
</div>`
    }
    public setEnabled(enabled: boolean): void
    {
        this.txInput.disabled = (enabled == false);
    }


    private initialTitle: string = null;
    private initialPlaceHolder: string = null;
    private initialText: string = null;
    private initialType: string = null;
    private initialMaxlength: number = null;

    public lbTitle: HTMLLabelElement = null;
    public txInput: HTMLInputElement = null;
    public divContainer: HTMLDivElement = null;

    constructor({ name, type = 'text', title = '', maxlength = 100, placeHolder = '', text = '' }:
        {
            name: string;
            type?: string;
            maxlength: number,
            title?: string;
            placeHolder?: string;
            text?: string;
        })
    {
        super(name);

        this.initialType = (Misc.isNullOrEmpty(type) ? 'text' : type);
        this.initialTitle = (Misc.isNullOrEmpty(title) ? '' : title);
        this.initialPlaceHolder = (Misc.isNullOrEmpty(placeHolder) ? '' : placeHolder);
        this.initialText = (Misc.isNullOrEmpty(text) ? '' : text);
        this.initialMaxlength = (Misc.isNullOrEmpty(maxlength) ? 100 : maxlength);
    }
    getBinder(): WidgetBinder
    {
        return new UITextBoxBinder(this);
    }

    applyMask(maskPattern: string): void
    {
        //making jQuery call
        var jQueryCall = `$('#${this.txInput.id}').mask('${maskPattern}'`;
        var a = Mask.array();
        var hasReverseFields = (
            (a.indexOf(Mask.CPF) +
                a.indexOf(Mask.CNPJ) +
                a.indexOf(Mask.MONEY) +
                a.indexOf(Mask.MONEY2)) >= 0)
        if (hasReverseFields)
            jQueryCall += ', {reverse: true});';
        else
            jQueryCall += ');';

        var maskFunction = new VirtualFunction({
            fnName: 'enableMask',
            fnContent: jQueryCall
        });
        maskFunction.call();
    }

    public setCustomPresenter(renderer: ICustomWidgetPresenter<UITextBox>): void
    {
        renderer.render(this);
    }

    public setInputType(inputType: string): void
    {
        this.txInput.type = inputType;
    }

    onWidgetDidLoad(): void
    {
        this.lbTitle = this.elementById('entryTitle');
        this.txInput = this.elementById('entryInput');
        this.divContainer = this.elementById('textEntry');
        this.lbTitle.innerText = this.initialTitle;
        this.txInput.placeholder = this.initialPlaceHolder;
        this.txInput.value = this.initialText;
        
        this.setMaxLength(this.initialMaxlength);
        this.setInputType(this.initialType);
    }

    public setMaxLength(maxlength: number): void
    {
        this.txInput.maxLength = maxlength;
    }

    public removeLabel()
    {
        this.lbTitle.remove();
    }
    public setPlaceholder(text: string): void
    {
        this.txInput.placeholder = text;
    }

    public getText(): string
    {
        return this.value();
    }

    public setText(newText: string): void
    {
        this.txInput.value = (Misc.isNullOrEmpty(newText) ? '' : newText);
    }

    public setTitle(newTitle: string): void
    {
        this.lbTitle.textContent = newTitle;
    }

    public value(): string
    {
        return this.txInput.value;
    }

    public addCSSClass(className: string): void 
    {
        this.txInput.classList.add(className);
    }

    public removeCSSClass(className: string): void
    {
        this.txInput.classList.remove(className);
    }

    public applyCSS(propertyName: string, propertyValue: string): void 
    {
        this.txInput.style.setProperty(propertyName, propertyValue);
    }

    public setPosition(position: string,
        marginLeft: string,
        marginTop: string,
        marginRight: string,
        marginBottom: string,
        transform?: string): void 
    {
        this.divContainer.style.position = position;
        this.divContainer.style.left = marginLeft;
        this.divContainer.style.top = marginTop;
        this.divContainer.style.right = marginRight;
        this.divContainer.style.bottom = marginBottom;
        this.divContainer.style.transform = transform;
    }

    public setVisible(visible: boolean): void 
    {
        this.divContainer.hidden = (visible == false);
    }

}
export class UIToast extends Widget
{
    protected onWidgetDidLoad(): void
    {
        throw new Error("Method not implemented.");
    }
    protected htmlTemplate(): string
    {
        throw new Error("Method not implemented.");
    }
    public setCustomPresenter(renderer: ICustomWidgetPresenter<Widget>): void
    {
        throw new Error("Method not implemented.");
    }
    public value(): string
    {
        throw new Error("Method not implemented.");
    }
    public setEnabled(enabled: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    public addCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public removeCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setVisible(visible: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    
}
export class DataGridItem implements IDataGridItemTemplate
{
    public value: any;
    public itemName: string;
    private ownerDatagrid: UIDataGrid;
    public rowElement: HTMLTableRowElement;
    private pageShell: PageShell;

    private selected: boolean = false;

    constructor(name: string,
        model: any | object,
        pageShell: PageShell)
    {
        this.pageShell = pageShell;
        this.itemName = name;
        this.value = model;
    }

    setOwnerDataGrid(dataGrid: UIDataGrid): void
    {
        this.ownerDatagrid = dataGrid;
    }
    isSelected(): boolean
    {
        return this.selected;
    }
    select(): void
    {
        this.selected = true;
        this.rowElement.style.background = this.ownerDatagrid.selectedBackColor;
        this.rowElement.style.color = this.ownerDatagrid.selectedForeColor;
    }
    unSelect(): void
    {
        this.selected = false;
        this.rowElement.style.background = this.ownerDatagrid.unselectedBackColor;
        this.rowElement.style.color = this.ownerDatagrid.unselectedForeColor;
    }
    itemTemplate(): HTMLTableRowElement
    {
        var self = this;
        if (self.rowElement != null)
            return self.rowElement;

        var model = self.value;
        var tr = self.pageShell.createElement('tr')
        
        for (var k = 0; k < this.ownerDatagrid.MODEL_KEYS.length; k++)
        {
            var key = this.ownerDatagrid.MODEL_KEYS[k];
            var td = this.pageShell.createElement('td');

            td.innerText = model[key];
            tr.appendChild(td);
        }
        tr.onclick = function (ev)
        {
            self.ownerDatagrid.onRowClick(self);
        };

        self.rowElement = tr;
        return tr;
    }
}
export interface IDataGridItemTemplateProvider
{
    getDataGridItemTemplate(sender: UIDataGrid, viewModel: any | object): IDataGridItemTemplate;
}
export interface IDataGridItemTemplate
{
    value: any | object;
    itemName: string;
    setOwnerDataGrid(dataGrid: UIDataGrid): void;
    isSelected(): boolean;
    select(): void;
    unSelect(): void;
    itemTemplate(): HTMLTableRowElement;
}
export interface IListItemTemplateProvider
{
    getListItemTemplate(sender: UIList, viewModel: any|object): IListItemTemplate;
}
export interface IListItemTemplate 
{
    value: any|object;
    itemName: string;
    setOwnerList(listView: UIList): void;
    isSelected(): boolean;
    select(): void;
    unSelect(): void;
    itemTemplate(): HTMLAnchorElement;
}
export class ListItem implements IListItemTemplate
{
    public value: any | object;
    public itemName: string;
    public itemText: string;
    public itemImageSource: string;
    public itemBadgeText: string;
    private ownerList: UIList;
    public anchorElement: HTMLAnchorElement;
    public imgElement: HTMLImageElement;
    public divElement: HTMLDivElement;
    public badgeElement: HTMLSpanElement;


    private selected: boolean = false;

    constructor(name: string,
        text: string,
        value?: any | object,
        imageSrc: string = null,
        badgeText: string = null)
    {
        this.value = value;
        this.itemName = name;
        this.itemText = text;
        this.itemImageSource = imageSrc;
        this.itemBadgeText = badgeText;
    }

    public setImg(src: string): void
    {
        if (Misc.isNullOrEmpty(src))
        {
            this.imgElement.hidden = true;
            this.imgElement.width = 0;
        }
        else
        {
            if (this.imgElement.hidden == true) this.imgElement.hidden = false;
            if (this.imgElement.width == 0) this.imgElement.width = 30;
            this.imgElement.src = src;
        }
    }

    public setText(text: string): void
    {
        this.divElement.textContent = text;
    }

    public setBadgeText(badgeText: string): void
    {
        this.badgeElement.textContent = badgeText;
    }

    public setOwnerList(listView: UIList)
    {
        this.ownerList = listView;
    }

    public isSelected(): boolean
    {
        return this.selected;
    }

    public select(): void
    {
        this.selected = true;

        if (this.ownerList.customBehaviorColors)
        {
            this.anchorElement.style.color = this.ownerList.selectedForeColor;
            this.anchorElement.style.backgroundColor = this.ownerList.selectedBackColor;
        }
        else
            this.anchorElement.classList.add('active');
    }

    public unSelect(): void
    {
        this.selected = false;
        if (this.ownerList.customBehaviorColors)
        {
            this.anchorElement.style.color = this.ownerList.unSelectedForeColor;
            this.anchorElement.style.backgroundColor = this.ownerList.unSelectedBackColor;
        }
        else
            this.anchorElement.classList.remove('active');
    }

    public itemTemplate(): HTMLAnchorElement
    {
        var self = this;
        if (self.anchorElement != null)
            return self.anchorElement;

        var pageShell = self.ownerList.getPageShell();

        self.anchorElement = pageShell.createElement('a');
        self.anchorElement.style.padding = '0px';
        self.anchorElement.classList.add('list-group-item', 'align-items-center', 'list-group-item-action');
        self.anchorElement.id = this.itemName;
        self.anchorElement.onclick = function (ev)
        {
            self.ownerList.onItemClicked(self, ev);
        };

        var rowDiv = pageShell.createElement('div');
        rowDiv.style.background = 'transparent';
        rowDiv.style.height = '40px';
        rowDiv.style.marginTop = '10px'
        rowDiv.classList.add('row');

        var col10Div = pageShell.createElement('div');
        col10Div.style.paddingLeft = '25px';
        col10Div.classList.add('col-10');

        var img: HTMLImageElement = null;
        if (this.itemImageSource != null)
        {
            img = pageShell.createElement('img');
            img.src = this.itemImageSource;
            img.style.marginRight = '10px';
            img.width = 30;
            img.height = 30;

            col10Div.append(img);
        }

        col10Div.append(this.itemText);

        rowDiv.append(col10Div);

        var badgeSpan: HTMLSpanElement = null;
        if (this.itemBadgeText != null)
        {
            var col2Div = pageShell.createElement('div');
            col2Div.style.display = 'flex'
            col2Div.style.justifyContent = 'end'
            col2Div.style.alignSelf = 'center'

            col2Div.classList.add('col-2');
            badgeSpan = pageShell.createElement('span');

            badgeSpan.classList.add('badge', 'badge-success', 'badge-pill');
            badgeSpan.textContent = this.itemBadgeText;
            badgeSpan.style.marginRight = '10px'

            col2Div.append(badgeSpan);
            rowDiv.append(col2Div);
        }

        self.anchorElement.append(rowDiv);
        self.badgeElement = badgeSpan;
        self.imgElement = img;
        self.divElement = rowDiv;

        this.unSelect();
        return self.anchorElement;
    }
}
export class UITemplateView
{
    public templateDOM: Document;
    public templateString: string;

    private viewDictionary: Array<ViewDictionaryEntry>;
    private shellPage: PageShell;
    constructor(htmlContent: string, shell: PageShell)
    {
        this.shellPage = shell;
        this.viewDictionary = [];
        //  this.parentFragment.clear();

        var html: string = htmlContent;
        var parser = new DOMParser();
        var domObj = parser.parseFromString(html, "text/html");
        var allIds = domObj.querySelectorAll('*[id]');

        for (var i = 0; i < allIds.length; i++)
        {
            var element = allIds[i];
            var currentId = element.getAttribute('id');
            if (currentId != null)
            {
                var newId = `${currentId}_${Widget.generateUUID()}`;
                this.addDictionaryEntry(currentId, newId);
                element.setAttribute('id', newId);
            }
        }

        this.templateDOM = domObj;
        this.templateString = domObj.children[0].outerHTML;
    }

    content(): Element
    {
        return this.templateDOM.children[0];
    }

    public elementById<TElement>(elementId: string): TElement
    {
       for (var i = 0; i < this.viewDictionary.length; i++)
        {
            var entry: ViewDictionaryEntry = this.viewDictionary[i];
            if (entry.getOriginalId() == elementId)
            {
                var elementResult: any = this.templateDOM.getElementById(entry.getManagedId());
                return elementResult;
            }
        }
        return null as unknown as TElement;
    }

    private addDictionaryEntry(originalId: string, generatedId: string)
    {
        var entry = new ViewDictionaryEntry(originalId, generatedId);
        this.viewDictionary.push(entry);
    }
}
export class DataGridColumnDefinition
{
    /**Column Header */
    public h: string;

    /**Model key (property) name */
    public k: string;
}

export class UIDataGridBinder extends WidgetBinder
{
    private dataGrid: UIDataGrid;
    constructor(dataGrid: UIDataGrid)
    {
        super(dataGrid);
        this.dataGrid = dataGrid;
    }

    getWidgetValue()
    {
        return this.dataGrid.selectedValue();
    }
    refreshUI(): void
    {
        var viewModels:Array<any|object> = this.getModelPropertyValue();
        this.dataGrid.fromList(viewModels);
    }
    fillPropertyModel(): void  { }
}

export class UIDataGrid extends Widget implements IBindable
{
    public autoGenerateColumns: boolean;
    public table: HTMLTableElement;
    public tableHeader: HTMLTableSectionElement;
    public tableBody: HTMLTableSectionElement;
    public selectedBackColor: string = '#007BFF';
    public unselectedBackColor: string = '#FFFFFF';

    public selectedForeColor: string = '#FFFFFF'
    public unselectedForeColor: string = '#000000'

    private templateProvider: IDataGridItemTemplateProvider;
    private items: Array<IDataGridItemTemplate> = [];

    public MODEL_KEYS: Array<string> = [];

    constructor({ name, autoGenCols = false, itemTemplateProvider = null }:
        {
            name: string,
            autoGenCols?: boolean,
            itemTemplateProvider?: IDataGridItemTemplateProvider
        })
    {
        super(name);
        this.templateProvider = itemTemplateProvider;
        this.autoGenerateColumns = autoGenCols;
    }
    getBinder(): WidgetBinder
    {
        return new UIDataGridBinder(this);
    }

    /**
     * 
     * @param colDefs array of { h: 'Column Header', k: 'model_property_name' }
     */
    public addColumns(colDefs: Array<DataGridColumnDefinition>): void
    {
        this.table.tHead.innerHTML = '';
        for (var i = 0; i < colDefs.length; i++)
        {
            var def: DataGridColumnDefinition = colDefs[i];
            this.addColumn(def.h, def.k);
        }
    }

    public addColumn(columnHeader: string, modelKey: string): void
    {
        var shell = this.getPageShell();
        this.MODEL_KEYS.push(modelKey);
        var thead = this.table.tHead;

        if (thead.childNodes.length == 0)
            thead.appendChild(shell.createElement('tr'));

        var th = shell.createElement('th', columnHeader);
        th.scope = 'col';
        thead.children[0].appendChild(th);
    }

    private generateColumns(list: Array<any>): void
    {
        this.autoGenerateColumns = false;
        this.table.tHead.innerHTML = '';
        this.MODEL_KEYS = [];

        var shell = this.getPageShell();

        //creating columns
        var tr: HTMLTableRowElement = shell.createElement('tr');
        let firstModel = list[0];
        for (let key in firstModel)
        {
            var th = shell.createElement('th');
            th.scope = 'col';
            th.textContent = key;
            tr.appendChild(th);
            this.MODEL_KEYS.push(key);
        }
        this.table.tHead.appendChild(tr);
    }

    public fromList(list: Array<any>): void
    {
        if ((list == null || list == undefined) || list.length == 0)
            return;

        this.table.tBodies[0].innerHTML = '';
        this.items = [];

        var shell = this.getPageShell();
        if (this.autoGenerateColumns)
            this.generateColumns(list);

        //adding rows
        for (var i = 0; i < list.length; i++)
        {
            var model = list[i];

            var itemTemplate: IDataGridItemTemplate;
            if (this.templateProvider == null)
                itemTemplate = new DataGridItem(`default_datagrid_item_${i + 1}`, model, shell);
            else
                itemTemplate = this.templateProvider.getDataGridItemTemplate(this, model);

            itemTemplate.setOwnerDataGrid(this);
            this.items.push(itemTemplate);
            this.table.tBodies[0].appendChild(itemTemplate.itemTemplate());
        }
    }

    public selectedItem(): IDataGridItemTemplate
    {
        for (var i = 0; i < this.items.length; i++)
            if (this.items[i].isSelected())
                return this.items[i];
        return null;
    }

    public selectedValue(): any | object
    {
        for (var i = 0; i < this.items.length; i++)
            if (this.items[i].isSelected())
                return this.items[i].value;
        return null;
    }

    public setSelectedItem(item: IDataGridItemTemplate): void
    {
        for (var i = 0; i < this.items.length; i++)
            this.items[i].unSelect();
        item.select();
    }

    public setSelectedValue(model: any | object): void
    {
        for (var i = 0; i < this.items.length; i++)
        {
            var item = this.items[i];
            if (item.value == model)
                item.select();
            else
                item.unSelect();
        }
    }

    public onRowClick(item: IDataGridItemTemplate): void
    {
        for (var i = 0; i < this.items.length; i++)
            this.items[i].unSelect();
        item.select();
    }

    protected htmlTemplate(): string
    {
        return `
<table id="fsDataGrid" class="table table-hover table-bordered table-sm">
  <thead id="gridHeader">
  </thead>
  <tbody id="gridBody" style="overflow-y:scrol; height: 100px">
  </tbody>
</table>        
`;
    }

    protected onWidgetDidLoad(): void
    {
        this.table = this.elementById('fsDataGrid');
        this.table.style.background = 'white';
        this.tableHeader = this.elementById('gridHeader');
        this.tableBody = this.elementById('gridBody');
    }

    public setCustomPresenter(presenter: ICustomWidgetPresenter<Widget>): void
    {
        presenter.render(this);
    }
    public value(): string
    {
        throw new Error("Method not implemented.");
    }
    public setEnabled(enabled: boolean): void
    {
        throw new Error("Method not implemented.");
    }
    public addCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public removeCSSClass(className: string): void
    {
        throw new Error("Method not implemented.");
    }
    public applyCSS(propertyName: string, propertyValue: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setPosition(position: string, marginLeft: string, marginTop: string, marginRight: string, marginBottom: string, transform?: string): void
    {
        throw new Error("Method not implemented.");
    }
    public setVisible(visible: boolean): void
    {
        throw new Error("Method not implemented.");
    }

}
